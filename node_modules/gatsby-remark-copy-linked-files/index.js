"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var visit = require(`unist-util-visit`);
var isRelativeUrl = require(`is-relative-url`);
var fs = require(`fs`);
var fsExtra = require(`fs-extra`);
var path = require(`path`);
var _ = require(`lodash`);
var cheerio = require(`cheerio`);
var imageSize = require(`probe-image-size`);

var DEPLOY_DIR = `public`;

var invalidDestinationDirMessage = function invalidDestinationDirMessage(dir) {
  return `[gatsby-remark-copy-linked-files You have supplied an invalid destination directory. The destination directory must be a child but was: ${dir}`;
};

// dir must be a child
var destinationDirIsValid = function destinationDirIsValid(dir) {
  return !path.relative(`./`, dir).startsWith(`..`);
};

var validateDestinationDir = function validateDestinationDir(dir) {
  return !dir || dir && destinationDirIsValid(dir);
};

var newFileName = function newFileName(linkNode) {
  return `${linkNode.name}-${linkNode.internal.contentDigest}.${linkNode.extension}`;
};

var newPath = function newPath(linkNode, destinationDir) {
  if (destinationDir) {
    return path.posix.join(process.cwd(), DEPLOY_DIR, destinationDir, newFileName(linkNode));
  }
  return path.posix.join(process.cwd(), DEPLOY_DIR, newFileName(linkNode));
};

var newLinkURL = function newLinkURL(linkNode, destinationDir, pathPrefix) {
  var _path$posix;

  var linkPaths = [`/`, pathPrefix, destinationDir, newFileName(linkNode)].filter(function (lpath) {
    if (lpath) return true;
    return false;
  });

  return (_path$posix = path.posix).join.apply(_path$posix, linkPaths);
};

function toArray(buf) {
  var arr = new Array(buf.length);

  for (var i = 0; i < buf.length; i++) {
    arr[i] = buf[i];
  }

  return arr;
}

module.exports = function (_ref) {
  var files = _ref.files,
      markdownNode = _ref.markdownNode,
      markdownAST = _ref.markdownAST,
      pathPrefix = _ref.pathPrefix,
      getNode = _ref.getNode;
  var pluginOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var defaults = {
    ignoreFileExtensions: [`png`, `jpg`, `jpeg`, `bmp`, `tiff`]
  };
  var destinationDir = pluginOptions.destinationDir;

  if (!validateDestinationDir(destinationDir)) return Promise.reject(invalidDestinationDirMessage(destinationDir));

  var options = _.defaults(pluginOptions, defaults);

  var filesToCopy = new Map();
  // Copy linked files to the destination directory and modify the AST to point
  // to new location of the files.
  var visitor = function visitor(link) {
    if (isRelativeUrl(link.url) && getNode(markdownNode.parent).internal.type === `File`) {
      var linkPath = path.posix.join(getNode(markdownNode.parent).dir, link.url);
      var linkNode = _.find(files, function (file) {
        if (file && file.absolutePath) {
          return file.absolutePath === linkPath;
        }
        return null;
      });
      if (linkNode && linkNode.absolutePath) {
        var newFilePath = newPath(linkNode, options.destinationDir);

        // Prevent uneeded copying
        if (linkPath === newFilePath) return;

        var linkURL = newLinkURL(linkNode, options.destinationDir, pathPrefix);
        link.url = linkURL;
        filesToCopy.set(linkPath, newFilePath);
      }
    }
  };

  // Takes a node and generates the needed images and then returns
  // the needed HTML replacement for the image
  var generateImagesAndUpdateNode = function generateImagesAndUpdateNode(image, node) {
    var imagePath = path.posix.join(getNode(markdownNode.parent).dir, image.attr(`src`));
    var imageNode = _.find(files, function (file) {
      if (file && file.absolutePath) {
        return file.absolutePath === imagePath;
      }
      return null;
    });
    if (!imageNode || !imageNode.absolutePath) {
      return;
    }

    var initialImageSrc = image.attr(`src`);
    // The link object will be modified to the new location so we'll
    // use that data to update our ref
    var link = { url: image.attr(`src`) };
    visitor(link);
    node.value = node.value.replace(new RegExp(image.attr(`src`), `g`), link.url);

    var dimensions = void 0;

    if (!image.attr(`width`) || !image.attr(`height`)) {
      dimensions = imageSize.sync(toArray(fs.readFileSync(imageNode.absolutePath)));
    }

    // Generate default alt tag
    var srcSplit = initialImageSrc.split(`/`);
    var fileName = srcSplit[srcSplit.length - 1];
    var fileNameNoExt = fileName.replace(/\.[^/.]+$/, ``);
    var defaultAlt = fileNameNoExt.replace(/[^A-Z0-9]/gi, ` `);

    image.attr(`alt`, image.attr(`alt`) ? image.attr(`alt`) : defaultAlt);
    image.attr(`width`, image.attr(`width`) ? image.attr(`width`) : dimensions.width);
    image.attr(`height`, image.attr(`height`) ? image.attr(`height`) : dimensions.height);
  };

  visit(markdownAST, `link`, function (link) {
    var ext = link.url.split(`.`).pop();
    if (options.ignoreFileExtensions.includes(ext)) {
      return;
    }

    visitor(link);
  });

  visit(markdownAST, `definition`, function (definition) {
    var ext = definition.url.split(`.`).pop();
    if (options.ignoreFileExtensions.includes(ext)) {
      return;
    }

    visitor(definition);
  });

  // This will only work for markdown img tags
  visit(markdownAST, `image`, function (image) {
    var ext = image.url.split(`.`).pop();
    if (options.ignoreFileExtensions.includes(ext)) {
      return;
    }

    // since dir will be undefined on non-files
    if (markdownNode.parent && getNode(markdownNode.parent).internal.type !== `File`) {
      return;
    }

    var imagePath = path.posix.join(getNode(markdownNode.parent).dir, image.url);
    var imageNode = _.find(files, function (file) {
      if (file && file.absolutePath) {
        return file.absolutePath === imagePath;
      }
      return false;
    });

    if (imageNode) {
      visitor(image);
    }
  });

  // For each HTML Node
  visit(markdownAST, `html`, function (node) {
    var $ = cheerio.load(node.value);

    // Handle Images
    var imageRefs = [];
    $(`img`).each(function () {
      try {
        if (isRelativeUrl($(this).attr(`src`))) {
          imageRefs.push($(this));
        }
      } catch (err) {
        // Ignore
      }
    });

    for (var _iterator = imageRefs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref2 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref2 = _i.value;
      }

      var thisImg = _ref2;

      try {
        var ext = thisImg.attr(`src`).split(`.`).pop();
        if (!options.ignoreFileExtensions.includes(ext)) {
          generateImagesAndUpdateNode(thisImg, node);
        }
      } catch (err) {
        // Ignore
      }
    }

    // Handle video tags.
    var videoRefs = [];
    $(`video source`).each(function () {
      try {
        if (isRelativeUrl($(this).attr(`src`))) {
          videoRefs.push($(this));
        }
      } catch (err) {
        // Ignore
      }
    });

    for (var _iterator2 = videoRefs, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref3 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref3 = _i2.value;
      }

      var thisVideo = _ref3;

      try {
        var _ext = thisVideo.attr(`src`).split(`.`).pop();
        if (!options.ignoreFileExtensions.includes(_ext)) {
          // The link object will be modified to the new location so we'll
          // use that data to update our ref
          var link = { url: thisVideo.attr(`src`) };
          visitor(link);
          node.value = node.value.replace(new RegExp(thisVideo.attr(`src`), `g`), link.url);
        }
      } catch (err) {
        // Ignore
      }
    }

    // Handle audio tags.
    var audioRefs = [];
    $(`audio source`).each(function () {
      try {
        if (isRelativeUrl($(this).attr(`src`))) {
          audioRefs.push($(this));
        }
      } catch (err) {
        // Ignore
      }
    });

    for (var _iterator3 = audioRefs, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref4 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref4 = _i3.value;
      }

      var thisAudio = _ref4;

      try {
        var _ext2 = thisAudio.attr(`src`).split(`.`).pop();
        if (!options.ignoreFileExtensions.includes(_ext2)) {
          var _link = { url: thisAudio.attr(`src`) };
          visitor(_link);
          node.value = node.value.replace(new RegExp(thisAudio.attr(`src`), `g`), _link.url);
        }
      } catch (err) {
        // Ignore
      }
    }

    // Handle a tags.
    var aRefs = [];
    $(`a`).each(function () {
      try {
        if (isRelativeUrl($(this).attr(`href`))) {
          aRefs.push($(this));
        }
      } catch (err) {
        // Ignore
      }
    });

    for (var _iterator4 = aRefs, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref5 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref5 = _i4.value;
      }

      var thisATag = _ref5;

      try {
        var _ext3 = thisATag.attr(`href`).split(`.`).pop();
        if (!options.ignoreFileExtensions.includes(_ext3)) {
          var _link2 = { url: thisATag.attr(`href`) };
          visitor(_link2);

          node.value = node.value.replace(new RegExp(thisATag.attr(`href`), `g`), _link2.url);
        }
      } catch (err) {
        // Ignore
      }
    }

    return;
  });

  return Promise.all(Array.from(filesToCopy, function () {
    var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref6) {
      var linkPath = _ref6[0],
          newFilePath = _ref6[1];
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (fsExtra.existsSync(newFilePath)) {
                _context.next = 11;
                break;
              }

              _context.prev = 1;
              _context.next = 4;
              return fsExtra.ensureDir(path.dirname(newFilePath));

            case 4:
              _context.next = 6;
              return fsExtra.copy(linkPath, newFilePath);

            case 6:
              _context.next = 11;
              break;

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](1);

              console.error(`error copying file`, _context.t0);

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, undefined, [[1, 8]]);
    }));

    return function (_x2) {
      return _ref7.apply(this, arguments);
    };
  }()));
};