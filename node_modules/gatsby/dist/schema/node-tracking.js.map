{"version":3,"sources":["../../src/schema/node-tracking.js"],"names":["_","require","getNode","getNodes","rootNodeMap","WeakMap","getRootNodeId","get","node","addRootNodeToInlineObject","data","nodeId","isPlainObject","isArray","each","o","set","trackInlineObjectsInRootNode","v","k","id","exports","findRootNodeAncestor","obj","predicate","rootNode","whileCount","rootNodeId","parent","undefined","console","log"],"mappings":";;AAAA,IAAMA,IAAIC,QAAS,QAAT,CAAV;;eAC8BA,QAAS,UAAT,C;IAAtBC,O,YAAAA,O;IAASC,Q,YAAAA,Q;;AAEjB;;;;;;;AAKA,IAAMC,cAAc,IAAIC,OAAJ,EAApB;;AAEA,IAAMC,gBAAgB,SAAhBA,aAAgB;AAAA,SAAQF,YAAYG,GAAZ,CAAgBC,IAAhB,CAAR;AAAA,CAAtB;;AAEA;;;;;;;AAOA,IAAMC,4BAA4B,SAA5BA,yBAA4B,CAACC,IAAD,EAAOC,MAAP,EAAkB;AAClD,MAAIX,EAAEY,aAAF,CAAgBF,IAAhB,KAAyBV,EAAEa,OAAF,CAAUH,IAAV,CAA7B,EAA8C;AAC5CV,MAAEc,IAAF,CAAOJ,IAAP,EAAa;AAAA,aAAKD,0BAA0BM,CAA1B,EAA6BJ,MAA7B,CAAL;AAAA,KAAb;AACAP,gBAAYY,GAAZ,CAAgBN,IAAhB,EAAsBC,MAAtB;AACD;AACF,CALD;;AAOA;;;;;AAKA;AACA,IAAMM,+BAA+B,SAA/BA,4BAA+B,OAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAjB,IAAEc,IAAF,CAAON,IAAP,EAAa,UAACU,CAAD,EAAIC,CAAJ,EAAU;AACrB;AACA,QAAIA,MAAO,UAAX,EAAsB;AACpB;AACD;AACDV,8BAA0BS,CAA1B,EAA6BV,KAAKY,EAAlC;AACD,GAND;;AAQA;AACA,SAAOZ,IAAP;AACD,CAnBD;AAoBAa,QAAQJ,4BAAR,GAAuCA,4BAAvC;;AAEA;;;;;;;AAOA,IAAMK,uBAAuB,SAAvBA,oBAAuB,CAACC,GAAD,EAA2B;AAAA,MAArBC,SAAqB,uEAAT,IAAS;;AACtD;AACA,MAAIC,WAAWF,GAAf;AACA,MAAIG,aAAa,CAAjB;AACA,MAAIC,mBAAJ;AACA,SACE,CAAC,CAACH,SAAD,IAAc,CAACA,UAAUC,QAAV,CAAhB,MACCE,aAAarB,cAAcmB,QAAd,KAA2BA,SAASG,MADlD,MAEC1B,QAAQuB,SAASG,MAAjB,MAA6BC,SAA7B,IAA0C3B,QAAQyB,UAAR,CAF3C,KAGAD,aAAa,GAJf,EAKE;AACA,QAAIC,UAAJ,EAAgB;AACdF,iBAAWvB,QAAQyB,UAAR,CAAX;AACD,KAFD,MAEO;AACLF,iBAAWvB,QAAQuB,SAASG,MAAjB,CAAX;AACD;AACDF,kBAAc,CAAd;AACA,QAAIA,aAAa,GAAjB,EAAsB;AACpBI,cAAQC,GAAR,CACG,+DADH,EAEEN,QAFF;AAID;AACF;;AAED,SAAO,CAACD,SAAD,IAAcA,UAAUC,QAAV,CAAd,GAAoCA,QAApC,GAA+C,IAAtD;AACD,CA1BD;;AA4BA;;;;;AAKAJ,QAAQC,oBAAR,GAA+BA,oBAA/B;;AAEA;AACAtB,EAAEc,IAAF,CAAOX,UAAP,EAAmB,gBAAQ;AACzBc,+BAA6BT,IAA7B;AACD,CAFD","file":"node-tracking.js","sourcesContent":["const _ = require(`lodash`)\nconst { getNode, getNodes } = require(`../redux`)\n\n/**\n * Map containing links between inline objects or arrays\n * and Node that contains them\n * @type {Object.<(Object|Array),string>}\n */\nconst rootNodeMap = new WeakMap()\n\nconst getRootNodeId = node => rootNodeMap.get(node)\n\n/**\n * Add link between passed data and Node. This function shouldn't be used\n * directly. Use higher level `trackInlineObjectsInRootNode`\n * @see trackInlineObjectsInRootNode\n * @param {(Object|Array)} data Inline object or array\n * @param {string} nodeId Id of node that contains data passed in first parameter\n */\nconst addRootNodeToInlineObject = (data, nodeId) => {\n  if (_.isPlainObject(data) || _.isArray(data)) {\n    _.each(data, o => addRootNodeToInlineObject(o, nodeId))\n    rootNodeMap.set(data, nodeId)\n  }\n}\n\n/**\n * Adds link between inline objects/arrays contained in Node object\n * and that Node object.\n * @param {Node} node Root Node\n */\n// const nodeDigestTracked = new Set()\nconst trackInlineObjectsInRootNode = node => {\n  // const id =\n  // node && node.internal && node.internal.contentDigest\n  // ? node.internal.contentDigest\n  // : node.id\n  // if (nodeDigestTracked.has(id)) {\n  // return node\n  // }\n\n  _.each(node, (v, k) => {\n    // Ignore the node internal object.\n    if (k === `internal`) {\n      return\n    }\n    addRootNodeToInlineObject(v, node.id)\n  })\n\n  // nodeDigestTracked.add(id)\n  return node\n}\nexports.trackInlineObjectsInRootNode = trackInlineObjectsInRootNode\n\n/**\n * Finds top most ancestor of node that contains passed Object or Array\n * @param {(Object|Array)} obj Object/Array belonging to Node object or Node object\n * @param {nodePredicate} [predicate] Optional callback to check if ancestor meets defined conditions\n * @returns {Node} Top most ancestor if predicate is not specified\n * or first node that meet predicate conditions if predicate is specified\n */\nconst findRootNodeAncestor = (obj, predicate = null) => {\n  // Find the root node.\n  let rootNode = obj\n  let whileCount = 0\n  let rootNodeId\n  while (\n    (!predicate || !predicate(rootNode)) &&\n    (rootNodeId = getRootNodeId(rootNode) || rootNode.parent) &&\n    (getNode(rootNode.parent) !== undefined || getNode(rootNodeId)) &&\n    whileCount < 101\n  ) {\n    if (rootNodeId) {\n      rootNode = getNode(rootNodeId)\n    } else {\n      rootNode = getNode(rootNode.parent)\n    }\n    whileCount += 1\n    if (whileCount > 100) {\n      console.log(\n        `It looks like you have a node that's set its parent as itself`,\n        rootNode\n      )\n    }\n  }\n\n  return !predicate || predicate(rootNode) ? rootNode : null\n}\n\n/**\n * @callback nodePredicate\n * @param {Node} node Node that is examined\n */\n\nexports.findRootNodeAncestor = findRootNodeAncestor\n\n// Track nodes that are already in store\n_.each(getNodes(), node => {\n  trackInlineObjectsInRootNode(node)\n})\n"]}