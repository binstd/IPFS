{"version":3,"sources":["../../../src/schema/types/type-file.js"],"names":["setFileNodeRootType","shouldInfer","getType","getListType","require","GraphQLList","_","mime","isRelative","isRelativeUrl","normalize","systemPath","getNodes","findRootNodeAncestor","createPageDependency","joinPath","type","listType","fileNodeRootType","createType","pointsToFile","nodes","key","value","looksLikeFile","isString","lookup","node","find","get","n","visit","current","selector","fn","i","keys","Object","length","undefined","concat","proceed","isNormalInteger","test","str","isMatch","v","k","parent","normalizedSelector","map","s","filter","fullSelector","join","rootNode","internal","pathToOtherNode","dir","otherFileExists","some","absolutePath","isEmpty","isArray","freeze","resolve","args","path","fieldName","fieldValue","findLinkedFileNode","fileLinkPath","parentFileNode","relativePath","linkedFileNode","nodeId","id"],"mappings":"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","file":"type-file.js","sourcesContent":["const { GraphQLList } = require(`graphql`)\nconst _ = require(`lodash`)\nconst mime = require(`mime`)\nconst isRelative = require(`is-relative`)\nconst isRelativeUrl = require(`is-relative-url`)\nconst normalize = require(`normalize-path`)\nconst systemPath = require(`path`)\n\nconst { getNodes } = require(`../../redux`)\nconst { findRootNodeAncestor } = require(`../node-tracking`)\nconst {\n  createPageDependency,\n} = require(`../../redux/actions/add-page-dependency`)\nconst { joinPath } = require(`../../utils/path`)\n\nlet type, listType\n\nexport function setFileNodeRootType(fileNodeRootType) {\n  if (fileNodeRootType) {\n    type = createType(fileNodeRootType, false)\n    listType = createType(fileNodeRootType, true)\n  } else {\n    type = null\n    listType = null\n  }\n}\n\nfunction pointsToFile(nodes, key, value) {\n  const looksLikeFile =\n    _.isString(value) &&\n    mime.lookup(value) !== `application/octet-stream` &&\n    // domains ending with .com\n    mime.lookup(value) !== `application/x-msdownload` &&\n    isRelative(value) &&\n    isRelativeUrl(value)\n\n  if (!looksLikeFile) {\n    return false\n  }\n\n  // Find the node used for this example.\n  let node = nodes.find(n => _.get(n, key) === value)\n\n  if (!node) {\n    // Try another search as our \"key\" isn't always correct e.g.\n    // it doesn't support arrays so the right key could be \"a.b[0].c\" but\n    // this function will get \"a.b.c\".\n    //\n    // We loop through every value of nodes until we find\n    // a match.\n    const visit = (current, selector = [], fn) => {\n      for (let i = 0, keys = Object.keys(current); i < keys.length; i++) {\n        const key = keys[i]\n        const value = current[key]\n\n        if (value === undefined || value === null) continue\n\n        if (typeof value === `object` || typeof value === `function`) {\n          visit(current[key], selector.concat([key]), fn)\n          continue\n        }\n\n        let proceed = fn(current[key], key, selector, current)\n\n        if (proceed === false) {\n          break\n        }\n      }\n    }\n\n    const isNormalInteger = str => /^\\+?(0|[1-9]\\d*)$/.test(str)\n\n    node = nodes.find(n => {\n      let isMatch = false\n      visit(n, [], (v, k, selector, parent) => {\n        if (v === value) {\n          // Remove integers as they're for arrays, which our passed\n          // in object path doesn't have.\n          const normalizedSelector = selector\n            .map(s => (isNormalInteger(s) ? `` : s))\n            .filter(s => s !== ``)\n          const fullSelector = `${normalizedSelector.join(`.`)}.${k}`\n          if (fullSelector === key) {\n            isMatch = true\n            return false\n          }\n        }\n\n        // Not a match so we continue\n        return true\n      })\n\n      return isMatch\n    })\n\n    // Still no node.\n    if (!node) {\n      return false\n    }\n  }\n\n  const rootNode = findRootNodeAncestor(node)\n\n  // Only nodes transformed (ultimately) from a File\n  // can link to another File.\n  if (rootNode.internal.type !== `File`) {\n    return false\n  }\n\n  const pathToOtherNode = normalize(joinPath(rootNode.dir, value))\n  const otherFileExists = getNodes().some(\n    n => n.absolutePath === pathToOtherNode\n  )\n  return otherFileExists\n}\n\nexport function shouldInfer(nodes, selector, value) {\n  return (\n    nodes[0].internal.type !== `File` &&\n    ((_.isString(value) &&\n      !_.isEmpty(value) &&\n      pointsToFile(nodes, selector, value)) ||\n      (_.isArray(value) &&\n        _.isString(value[0]) &&\n        !_.isEmpty(value[0]) &&\n        pointsToFile(nodes, `${selector}[0]`, value[0])))\n  )\n}\n\nfunction createType(fileNodeRootType, isArray) {\n  if (!fileNodeRootType) return null\n\n  return Object.freeze({\n    type: isArray ? new GraphQLList(fileNodeRootType) : fileNodeRootType,\n    resolve: (node, args, { path }, { fieldName }) => {\n      let fieldValue = node[fieldName]\n\n      if (!fieldValue) {\n        return null\n      }\n\n      const findLinkedFileNode = relativePath => {\n        // Use the parent File node to create the absolute path to\n        // the linked file.\n        const fileLinkPath = normalize(\n          systemPath.resolve(parentFileNode.dir, relativePath)\n        )\n\n        // Use that path to find the linked File node.\n        const linkedFileNode = _.find(\n          getNodes(),\n          n => n.internal.type === `File` && n.absolutePath === fileLinkPath\n        )\n        if (linkedFileNode) {\n          createPageDependency({\n            path,\n            nodeId: linkedFileNode.id,\n          })\n          return linkedFileNode\n        } else {\n          return null\n        }\n      }\n\n      // Find the File node for this node (we assume the node is something\n      // like markdown which would be a child node of a File node).\n      const parentFileNode = findRootNodeAncestor(node)\n\n      // Find the linked File node(s)\n      if (isArray) {\n        return fieldValue.map(relativePath => findLinkedFileNode(relativePath))\n      } else {\n        return findLinkedFileNode(fieldValue)\n      }\n    },\n  })\n}\n\nexport function getType() {\n  return type\n}\n\nexport function getListType() {\n  return listType\n}\n"]}