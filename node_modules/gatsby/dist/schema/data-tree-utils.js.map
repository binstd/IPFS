{"version":3,"sources":["../../src/schema/data-tree-utils.js"],"names":["_","require","flatten","typeOf","invariant","createKey","typeConflictReporter","INVALID_VALUE","Symbol","isDefined","v","isEmptyObjectOrArray","obj","isDate","isObject","isEmpty","every","value","key","isScalar","val","Date","extractTypes","Array","isArray","uniqueTypes","uniq","filter","map","item","type","sort","join","arrayTypes","getExampleScalarFromArray","reduce","values","nextValue","isNumber","isInteger","extractFromEntries","entries","selector","entriesOfUniqueType","uniqBy","entry","length","addConflict","exampleValue","concatanedItems","concat","includes","extractFromArrays","isPlainObject","extractFieldExamples","filteredItems","flattenEntries","parent","arrayItemExample","nodes","ignoreFields","allKeys","flatMap","keys","example","nextSelector","nodeWithValues","node","buildFieldEnumValues","options","enumValues","getExampleValues","maxDepth","safe","delimiter","Object","forEach","field","typeExampleValues","Map","clearTypeExampleValues","clear","clearConflicts","typeName","cachedValue","get","set","extractFieldNames","module","exports"],"mappings":"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","file":"data-tree-utils.js","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst flatten = require(`flat`)\nconst typeOf = require(`type-of`)\nconst invariant = require(`invariant`)\n\nconst createKey = require(`./create-key`)\nconst { typeConflictReporter } = require(`./type-conflict-reporter`)\n\nimport type { TypeEntry } from \"./type-conflict-reporter\"\n\ntype ExampleValue = Object\n\nconst INVALID_VALUE = Symbol(`INVALID_VALUE`)\nconst isDefined = v => v != null\n\nconst isEmptyObjectOrArray = (obj: any): boolean => {\n  if (obj === INVALID_VALUE) {\n    return true\n  } else if (_.isDate(obj)) {\n    return false\n    // Simple \"is object empty\" check.\n  } else if (_.isObject(obj) && _.isEmpty(obj)) {\n    return true\n  } else if (_.isObject(obj)) {\n    return _.every(obj, (value, key) => {\n      if (!isDefined(value)) {\n        return true\n      } else if (_.isObject(value)) {\n        return isEmptyObjectOrArray(value)\n      } else {\n        return false\n      }\n    })\n  }\n  return false\n}\n\nconst isScalar = val => !_.isObject(val) || val instanceof Date\n\nconst extractTypes = value => {\n  if (Array.isArray(value)) {\n    const uniqueTypes = _.uniq(\n      value.filter(isDefined).map(item => extractTypes(item).type)\n    ).sort()\n    return {\n      type: `array<${uniqueTypes.join(`|`)}>`,\n      arrayTypes: uniqueTypes,\n    }\n  } else {\n    const type = typeOf(value)\n    return {\n      type,\n      arrayTypes: [],\n    }\n  }\n}\n\nconst getExampleScalarFromArray = values =>\n  _.reduce(\n    values,\n    (value, nextValue) => {\n      // Prefer floats over ints as they're more specific.\n      if (nextValue && _.isNumber(nextValue) && !_.isInteger(nextValue)) {\n        return nextValue\n      } else if (value === null) {\n        return nextValue\n      } else {\n        return value\n      }\n    },\n    null\n  )\n\nconst extractFromEntries = (\n  entries: TypeEntry[],\n  selector: string,\n  key: string\n): ?mixed => {\n  const entriesOfUniqueType = _.uniqBy(entries, entry => entry.type)\n\n  if (entriesOfUniqueType.length == 0) {\n    // skip if no defined types\n    return null\n  } else if (\n    entriesOfUniqueType.length > 1 ||\n    entriesOfUniqueType[0].arrayTypes.length > 1\n  ) {\n    // there is multiple types or array of multiple types\n    if (selector) {\n      typeConflictReporter.addConflict(selector, entriesOfUniqueType)\n    }\n    return INVALID_VALUE\n  }\n\n  // Now we have entries of single type, we can merge them\n  const values = entries.map(entry => entry.value)\n\n  const exampleValue = entriesOfUniqueType[0].value\n\n  if (isScalar(exampleValue)) {\n    return getExampleScalarFromArray(values)\n  } else if (_.isObject(exampleValue)) {\n    if (Array.isArray(exampleValue)) {\n      const concatanedItems = [].concat(...values)\n      // Linked node arrays don't get reduced further as we\n      // want to preserve all the linked node types.\n      if (key.includes(`___NODE`)) {\n        return concatanedItems\n      }\n\n      return extractFromArrays(concatanedItems, entries, selector)\n    } else if (_.isPlainObject(exampleValue)) {\n      return extractFieldExamples(values, selector)\n    }\n  }\n  // unsuported object\n  return INVALID_VALUE\n}\n\nconst extractFromArrays = (values, entries: TypeEntry[], selector: string) => {\n  const filteredItems = values.filter(isDefined)\n  if (filteredItems.length === 0) {\n    return null\n  }\n  if (isScalar(filteredItems[0])) {\n    return [getExampleScalarFromArray(filteredItems)]\n  }\n\n  const flattenEntries: TypeEntry[] = _.flatten(\n    entries.map(entry => {\n      invariant(\n        Array.isArray(entry.value),\n        `this is validated in the previous call`\n      )\n\n      return entry.value.map(value => {\n        return {\n          value,\n          parent: entry.parent,\n          ...extractTypes(value),\n        }\n      })\n    })\n  )\n\n  const arrayItemExample = extractFromEntries(\n    flattenEntries,\n    `${selector}[]`,\n    ``\n  )\n  if (!isDefined(arrayItemExample) || arrayItemExample === INVALID_VALUE) {\n    return INVALID_VALUE\n  }\n\n  return [arrayItemExample]\n}\n\n/**\n * Takes an array of source nodes and returns a pristine\n * example that can be used to infer types.\n *\n * Arrays are flattened to either: `null` for empty or sparse arrays or a\n * an array of a sigle merged example. e.g:\n *\n *  - ['red'], ['blue', 'yellow'] -> ['red']\n *  - [{ color: 'red'}, { color: 'blue', ht: 5 }] -> [{ color: 'red', ht: 5 }]\n *\n * @param {*Nodes} args\n */\nconst extractFieldExamples = (\n  nodes: any[],\n  selector: string,\n  ignoreFields?: string[] = []\n): ExampleValue => {\n  // get list of keys in all nodes\n  const allKeys = _(nodes)\n    .flatMap(_.keys)\n    .uniq()\n\n  const example = {}\n  for (let key of allKeys) {\n    if (ignoreFields.includes(key)) continue\n    const nextSelector = selector ? `${selector}.${key}` : key\n\n    const nodeWithValues = nodes.filter(node => {\n      if (!node) return false\n\n      const value = node[key]\n      if (_.isObject(value)) {\n        return !isEmptyObjectOrArray(value)\n      } else {\n        return isDefined(value)\n      }\n    })\n\n    // we want to keep track of nodes as we need it to get origin of data\n    const entries = nodeWithValues.map(node => {\n      const value = node[key]\n      return {\n        value,\n        parent: node,\n        ...extractTypes(value),\n      }\n    })\n\n    const value = extractFromEntries(entries, nextSelector, key)\n    if (!isDefined(value)) continue\n\n    example[key] = value\n  }\n\n  return example\n}\n\nconst buildFieldEnumValues = (options: ExampleValueOptions) => {\n  const enumValues = {}\n  const values = flatten(getExampleValues(options), {\n    maxDepth: 3,\n    safe: true, // don't flatten arrays.\n    delimiter: `___`,\n  })\n  Object.keys(values).forEach(field => {\n    if (values[field] == null) return\n    enumValues[createKey(field)] = { field }\n  })\n\n  return enumValues\n}\n\nlet typeExampleValues: Map<string, Object> = new Map()\n\nconst clearTypeExampleValues = () => {\n  typeExampleValues.clear()\n  typeConflictReporter.clearConflicts()\n}\n\ntype ExampleValueOptions = {\n  nodes: Object[],\n  typeName?: string,\n  ignoreFields?: string[],\n}\n\nconst getExampleValues = ({\n  nodes,\n  typeName,\n  ignoreFields,\n}: ExampleValueOptions): ExampleValue => {\n  const cachedValue = typeName && typeExampleValues.get(typeName)\n\n  // if type is defined and is in example value cache return it\n  if (cachedValue) return cachedValue\n\n  // if nodes were passed extract field example from it\n  if (nodes && nodes.length > 0) {\n    const exampleValue = extractFieldExamples(\n      nodes,\n      typeName || ``,\n      ignoreFields\n    )\n    // if type is set - cache results\n    if (typeName) typeExampleValues.set(typeName, exampleValue)\n    return exampleValue\n  }\n\n  return {}\n}\n\n// extract a list of field names\n// nested objects get flattened to \"outer___inner\" which will be converted back to\n// \"outer.inner\" by run-sift\nconst extractFieldNames = (nodes: Object[]) => {\n  const values = flatten(\n    getExampleValues({\n      nodes,\n      typeName: _.get(nodes[0], `internal.type`),\n    }),\n    {\n      maxDepth: 3,\n      safe: true, // don't flatten arrays.\n      delimiter: `___`,\n    }\n  )\n\n  return Object.keys(values)\n}\n\nmodule.exports = {\n  INVALID_VALUE,\n  buildFieldEnumValues,\n  extractFieldNames,\n  isEmptyObjectOrArray,\n  clearTypeExampleValues,\n  getExampleValues,\n}\n"]}