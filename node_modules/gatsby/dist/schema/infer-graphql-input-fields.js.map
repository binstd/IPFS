{"version":3,"sources":["../../src/schema/infer-graphql-input-fields.js"],"names":["inferInputObjectStructureFromNodes","require","GraphQLInputObjectType","GraphQLBoolean","GraphQLString","GraphQLFloat","GraphQLInt","GraphQLList","oneLine","_","invariant","typeOf","createTypeName","createKey","getExampleValues","extractFieldNames","isEmptyObjectOrArray","findLinkedNode","getNodes","typeFields","type","eq","ne","regex","glob","gt","gte","lt","lte","inferGraphQLInputFields","value","nodes","prefix","headValue","headType","isInteger","inType","inferredField","JSON","stringify","Object","keys","name","fields","in","exampleValue","inferredFields","isEmpty","EXCLUDE_KEYS","parent","children","recursiveOmitBy","fn","isObject","isPlainObject","omitBy","each","v","k","linkedNodeCache","typeName","isRoot","internal","key","includes","nodeToFind","isArray","linkedNode","relatedNodes","filter","node","_v","_k","split","field","upperFirst","sort"],"mappings":"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","file":"infer-graphql-input-fields.js","sourcesContent":["// @flow\nconst {\n  GraphQLInputObjectType,\n  GraphQLBoolean,\n  GraphQLString,\n  GraphQLFloat,\n  GraphQLInt,\n  GraphQLList,\n} = require(`graphql`)\nconst { oneLine } = require(`common-tags`)\nconst _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst typeOf = require(`type-of`)\nconst createTypeName = require(`./create-type-name`)\nconst createKey = require(`./create-key`)\nconst {\n  getExampleValues,\n  extractFieldNames,\n  isEmptyObjectOrArray,\n} = require(`./data-tree-utils`)\n\nconst { findLinkedNode } = require(`./infer-graphql-type`)\nconst { getNodes } = require(`../redux`)\n\nimport type {\n  GraphQLInputFieldConfig,\n  GraphQLInputFieldConfigMap,\n} from \"graphql/type/definition\"\n\nfunction typeFields(type): GraphQLInputFieldConfigMap {\n  switch (type) {\n    case `boolean`:\n      return {\n        eq: { type: GraphQLBoolean },\n        ne: { type: GraphQLBoolean },\n      }\n    case `string`:\n      return {\n        eq: { type: GraphQLString },\n        ne: { type: GraphQLString },\n        regex: { type: GraphQLString },\n        glob: { type: GraphQLString },\n      }\n    case `int`:\n      return {\n        eq: { type: GraphQLInt },\n        ne: { type: GraphQLInt },\n        gt: { type: GraphQLInt },\n        gte: { type: GraphQLInt },\n        lt: { type: GraphQLInt },\n        lte: { type: GraphQLInt },\n      }\n    case `float`:\n      return {\n        eq: { type: GraphQLFloat },\n        ne: { type: GraphQLFloat },\n        gt: { type: GraphQLFloat },\n        gte: { type: GraphQLFloat },\n        lt: { type: GraphQLFloat },\n        lte: { type: GraphQLFloat },\n      }\n  }\n  return {}\n}\n\nfunction inferGraphQLInputFields({\n  value,\n  nodes,\n  prefix,\n}): ?GraphQLInputFieldConfig {\n  if (value == null || isEmptyObjectOrArray(value)) return null\n\n  switch (typeOf(value)) {\n    case `array`: {\n      const headValue = value[0]\n      let headType = typeOf(headValue)\n\n      if (headType === `number`)\n        headType = _.isInteger(headValue) ? `int` : `float`\n\n      // Determine type for in operator.\n      let inType\n      switch (headType) {\n        case `int`:\n          inType = GraphQLInt\n          break\n        case `float`:\n          inType = GraphQLFloat\n          break\n        case `date`:\n        case `string`:\n          inType = GraphQLString\n          break\n        case `boolean`:\n          inType = GraphQLBoolean\n          break\n        case `array`:\n        case `object`: {\n          let inferredField = inferGraphQLInputFields({\n            value: headValue,\n            prefix,\n            nodes,\n          })\n          invariant(\n            inferredField,\n            `Could not infer graphQL type for value: ${JSON.stringify(\n              Object.keys(headValue)\n            )}`\n          )\n          inType = inferredField.type\n          break\n        }\n        default:\n          invariant(\n            false,\n            oneLine`\n              Could not infer an appropriate GraphQL input type\n              for value: ${headValue} of type ${headType} along path: ${prefix}\n            `\n          )\n      }\n\n      return {\n        type: new GraphQLInputObjectType({\n          name: createTypeName(`${prefix}QueryList`),\n          fields: {\n            ...typeFields(headType),\n            in: { type: new GraphQLList(inType) },\n          },\n        }),\n      }\n    }\n    case `boolean`: {\n      return {\n        type: new GraphQLInputObjectType({\n          name: createTypeName(`${prefix}QueryBoolean`),\n          fields: typeFields(`boolean`),\n        }),\n      }\n    }\n    case `date`:\n    case `string`: {\n      return {\n        type: new GraphQLInputObjectType({\n          name: createTypeName(`${prefix}QueryString`),\n          fields: typeFields(`string`),\n        }),\n      }\n    }\n    case `object`: {\n      const fields = inferInputObjectStructureFromNodes({\n        nodes,\n        prefix,\n        exampleValue: value,\n      }).inferredFields\n      if (!_.isEmpty(fields)) {\n        return {\n          type: new GraphQLInputObjectType({\n            name: createTypeName(`${prefix}InputObject`),\n            fields,\n          }),\n        }\n      } else {\n        return null\n      }\n    }\n    case `number`: {\n      if (value % 1 === 0) {\n        return {\n          type: new GraphQLInputObjectType({\n            name: createTypeName(`${prefix}QueryInteger`),\n            fields: typeFields(`int`),\n          }),\n        }\n      } else {\n        return {\n          type: new GraphQLInputObjectType({\n            name: createTypeName(`${prefix}QueryFloat`),\n            fields: typeFields(`float`),\n          }),\n        }\n      }\n    }\n    default:\n      return null\n  }\n}\n\nconst EXCLUDE_KEYS = {\n  parent: 1,\n  children: 1,\n}\n\ntype InferInputOptions = {\n  nodes: Object[],\n  typeName?: string,\n  prefix?: string,\n  exampleValue?: Object,\n}\n\nconst recursiveOmitBy = (value, fn) => {\n  if (_.isObject(value)) {\n    if (_.isPlainObject(value)) {\n      value = _.omitBy(value, fn)\n    }\n    _.each(value, (v, k) => {\n      value[k] = recursiveOmitBy(v, fn)\n    })\n    if (_.isEmpty(value)) {\n      // don't return empty objects - gatsby doesn't support these\n      return null\n    }\n  }\n  return value\n}\n\nconst linkedNodeCache = {}\n\nexport function inferInputObjectStructureFromNodes({\n  nodes,\n  typeName = ``,\n  prefix = ``,\n  exampleValue = null,\n}: InferInputOptions): Object {\n  const inferredFields = {}\n  const isRoot = !prefix\n\n  prefix = isRoot ? typeName : prefix\n  if (exampleValue === null) {\n    // typeName includes \"Connection\" string, which is not what we want,\n    // so extract type from first node\n    exampleValue = getExampleValues({\n      nodes,\n      typeName:\n        nodes && nodes[0] && nodes[0].internal && nodes[0].internal.type,\n    })\n  }\n\n  _.each(exampleValue, (v, k) => {\n    let value = v\n    let key = k\n    // Remove fields for traversing through nodes as we want to control\n    // setting traversing up not try to automatically infer them.\n    if (isRoot && EXCLUDE_KEYS[key]) return\n\n    if (_.includes(key, `___NODE`)) {\n      // TODO: Union the objects in array\n      const nodeToFind = _.isArray(value) ? value[0] : value\n      const linkedNode = findLinkedNode(nodeToFind)\n\n      // Get from cache if found, else store into it\n      if (linkedNodeCache[linkedNode.internal.type]) {\n        value = linkedNodeCache[linkedNode.internal.type]\n      } else {\n        const relatedNodes = getNodes().filter(\n          node => node.internal.type === linkedNode.internal.type\n        )\n        value = getExampleValues({\n          nodes: relatedNodes,\n          typeName: linkedNode.internal.type,\n        })\n        value = recursiveOmitBy(value, (_v, _k) => _.includes(_k, `___NODE`))\n        linkedNodeCache[linkedNode.internal.type] = value\n      }\n\n      if (_.isArray(value)) {\n        value = [value]\n      }\n\n      ;[key] = key.split(`___`)\n    }\n\n    let field = inferGraphQLInputFields({\n      nodes,\n      value,\n      prefix: `${prefix}${_.upperFirst(key)}`,\n    })\n\n    if (field == null) return\n    inferredFields[createKey(key)] = field\n  })\n\n  // Add sorting (but only to the top level).\n  let sort = []\n  if (typeName) {\n    sort = extractFieldNames(nodes)\n  }\n\n  return { inferredFields, sort }\n}\n"]}