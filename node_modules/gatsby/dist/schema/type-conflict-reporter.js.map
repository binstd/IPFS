{"version":3,"sources":["../../src/schema/type-conflict-reporter.js"],"names":["_","require","report","typeOf","util","findRootNodeAncestor","isNodeWithDescription","node","internal","description","findNodeDescription","obj","formatValue","isArray","value","inspect","colors","depth","breakLength","Infinity","wasElipsisLast","usedTypes","output","forEach","type","item","indexOf","push","join","TypeConflictEntry","selector","types","Map","addExample","parent","set","printEntry","sortedByTypeName","sortBy","Array","from","entries","typeName","log","map","TypeConflictReporter","clearConflicts","clear","getEntryFromSelector","dataEntry","get","addConflict","examples","substring","entry","filter","example","printConflicts","size","warn","typeConflictReporter","module","exports"],"mappings":"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","file":"type-conflict-reporter.js","sourcesContent":["// @flow\nconst _ = require(`lodash`)\nconst report = require(`gatsby-cli/lib/reporter`)\nconst typeOf = require(`type-of`)\nconst util = require(`util`)\nconst { findRootNodeAncestor } = require(`./node-tracking`)\n\nexport type TypeConflictExample = {\n  value: mixed,\n  parent: {},\n  type: string,\n  arrayTypes: string[],\n}\n\ntype TypeConflict = {\n  value: mixed,\n  description: string,\n}\n\nconst isNodeWithDescription = node =>\n  node && node.internal && node.internal.description\n\nconst findNodeDescription = obj => {\n  if (obj) {\n    const node = findRootNodeAncestor(obj, isNodeWithDescription)\n    if (isNodeWithDescription(node)) {\n      return node.internal.description\n    }\n  }\n  return ``\n}\n\nconst formatValue = value => {\n  if (!_.isArray(value)) {\n    return util.inspect(value, {\n      colors: true,\n      depth: 0,\n      breakLength: Infinity,\n    })\n  }\n\n  let wasElipsisLast = false\n  const usedTypes = []\n  const output = []\n\n  value.forEach(item => {\n    const type = typeOf(item)\n    if (usedTypes.indexOf(type) !== -1) {\n      if (!wasElipsisLast) {\n        output.push(`...`)\n        wasElipsisLast = true\n      }\n    } else {\n      output.push(formatValue(item))\n      wasElipsisLast = false\n      usedTypes.push(type)\n    }\n  })\n\n  return `[ ${output.join(`, `)} ]`\n}\n\nclass TypeConflictEntry {\n  selector: string\n  types: Map<string, TypeConflict>\n\n  constructor(selector: string) {\n    this.selector = selector\n    this.types = new Map()\n  }\n\n  addExample({ value, type, parent }: TypeConflictExample) {\n    this.types.set(type, {\n      value,\n      description: findNodeDescription(parent),\n    })\n  }\n\n  printEntry() {\n    const sortedByTypeName = _.sortBy(\n      Array.from(this.types.entries()),\n      ([typeName, value]) => typeName\n    )\n\n    report.log(\n      `${this.selector}:${sortedByTypeName\n        .map(\n          ([typeName, { value, description }]) =>\n            `\\n - type: ${typeName}\\n   value: ${formatValue(\n              value\n            )}${description && `\\n   source: ${description}`}`\n        )\n        .join(``)}`\n    )\n  }\n}\n\nclass TypeConflictReporter {\n  entries: Map<string, TypeConflictEntry>\n\n  constructor() {\n    this.entries = new Map()\n  }\n\n  clearConflicts() {\n    this.entries.clear()\n  }\n\n  getEntryFromSelector(selector: string): TypeConflictEntry {\n    let dataEntry = this.entries.get(selector)\n\n    if (!dataEntry) {\n      dataEntry = new TypeConflictEntry(selector)\n      this.entries.set(selector, dataEntry)\n    }\n\n    return dataEntry\n  }\n\n  addConflict(selector: string, examples: TypeConflictExample[]) {\n    if (selector.substring(0, 11) === `SitePlugin.`) {\n      // Don't store and print out type conflicts in plugins.\n      // This is out of user control so he can't do anything\n      // to hide those.\n      return\n    }\n\n    const entry = this.getEntryFromSelector(selector)\n    examples\n      .filter(example => example.value != null)\n      .forEach(example => entry.addExample(example))\n  }\n\n  printConflicts() {\n    if (this.entries.size > 0) {\n      report.warn(\n        `There are conflicting field types in your data. GraphQL schema will omit those fields.`\n      )\n      this.entries.forEach(entry => entry.printEntry())\n    }\n  }\n}\n\nconst typeConflictReporter = new TypeConflictReporter()\n\nconst printConflicts = () => {\n  typeConflictReporter.printConflicts()\n}\n\nmodule.exports = { typeConflictReporter, printConflicts, TypeConflictEntry }\n"]}