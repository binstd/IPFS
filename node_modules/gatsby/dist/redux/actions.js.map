{"version":3,"sources":["../../src/redux/actions.js"],"names":["joiSchemas","_","require","bindActionCreators","stripIndent","report","glob","path","fs","joinPath","hasNodeChanged","getNode","trackInlineObjectsInRootNode","store","actions","findChildrenRecursively","children","concat","map","newChildren","child","isArray","length","deletePage","page","type","payload","pascalCase","flow","camelCase","upperFirst","hasWarnedForPageComponent","Set","createPage","plugin","traceId","noPageOrComponent","name","message","process","env","NODE_ENV","console","log","chalk","bold","red","isObject","context","reservedFields","invalidFields","Object","keys","pick","singularMessage","pluralMessage","error","f","join","JSON","stringify","some","panic","has","component","warn","add","existsSync","isAbsolute","exit","jsonName","kebabCase","internalComponentName","layout","sync","getState","program","directory","internalPage","matchPath","componentChunkName","updatedAt","Date","now","result","Joi","validate","pageSchema","blue","bgYellow","includes","fileContent","readFileSync","notEmpty","includesDefaultExport","relativePath","relative","deleteLayout","createLayout","id","parse","machineId","componentWrapperPath","internalLayout","isLayout","layoutSchema","deleteNode","nodeId","node","deleteDescendantsActions","descendantNodes","n","deleteAction","deleteNodes","nodes","flatten","deleteNodesAction","typeOwners","createNode","internal","owner","nodeSchema","fields","Error","oldNode","pluginName","updateNodeAction","contentDigest","touchNode","createNodeField","value","fieldName","fieldValue","fieldOwners","schemaFieldName","split","fieldOwner","createParentChildLink","parent","push","uniq","createPageDependency","connection","deleteComponentsDependencies","paths","replaceComponentQuery","query","componentPath","createJob","job","setJob","endJob","setPluginStatus","status","createRedirect","fromPath","isPermanent","redirectInBrowser","toPath","rest","pathPrefix","prefixPaths","config","exports","boundActionCreators","dispatch"],"mappings":";;;;;;;;;;AACA;;;;AACA;;;;AAYA;;IAAYA,U;;AACZ;;;;;;AAZA,IAAMC,IAAIC,QAAS,QAAT,CAAV;;eAC+BA,QAAS,OAAT,C;IAAvBC,kB,YAAAA,kB;;gBACgBD,QAAS,aAAT,C;IAAhBE,W,aAAAA,W;;AACR,IAAMC,SAASH,QAAS,yBAAT,CAAf;AACA,IAAMI,OAAOJ,QAAS,MAAT,CAAb;AACA,IAAMK,OAAOL,QAAS,MAAT,CAAb;AACA,IAAMM,KAAKN,QAAS,IAAT,CAAX;;gBACqBA,QAAS,eAAT,C;IAAbO,Q,aAAAA,Q;;gBAC4BP,QAAS,SAAT,C;IAA5BQ,c,aAAAA,c;IAAgBC,O,aAAAA,O;;gBACiBT,QAAS,yBAAT,C;IAAjCU,4B,aAAAA,4B;;gBACUV,QAAS,SAAT,C;IAAVW,K,aAAAA,K;;AAIR,IAAMC,UAAU,EAAhB;;AAEA,IAAMC,0BAA0B,SAA1BA,uBAA0B,GAAmB;AAAA;;AAAA,MAAlBC,QAAkB,uEAAP,EAAO;;AACjDA,aAAW,uBAASC,MAAT,kBACND,SAASE,GAAT,CAAa,iBAAS;AACvB,QAAMC,cAAcR,QAAQS,KAAR,EAAeJ,QAAnC;AACA,QAAIf,EAAEoB,OAAF,CAAUF,WAAV,KAA0BA,YAAYG,MAAZ,GAAqB,CAAnD,EAAsD;AACpD,aAAOP,wBAAwBI,WAAxB,CAAP;AACD,KAFD,MAEO;AACL,aAAO,EAAP;AACD;AACF,GAPE,CADM,CAAX;;AAWA,SAAOH,QAAP;AACD,CAbD;;AA2DA;;;;;;;;AAQAF,QAAQS,UAAR,GAAqB,UAACC,IAAD,EAAqB;AACxC,SAAO;AACLC,UAAO,aADF;AAELC,aAASF;AAFJ,GAAP;AAID,CALD;;AAOA,IAAMG,aAAa1B,EAAE2B,IAAF,CACjB3B,EAAE4B,SADe,EAEjB5B,EAAE6B,UAFe,CAAnB;AAIA,IAAMC,4BAA4B,IAAIC,GAAJ,EAAlC;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAwBAlB,QAAQmB,UAAR,GAAqB,UAACT,IAAD,EAAkBU,MAAlB,EAAmCC,OAAnC,EAAwD;AAC3E,MAAIC,oBAAoB,KAAxB;AACA,MAAIC,OAAQ,eAAcH,OAAOG,IAAK,GAAtC;AACA,MAAIH,OAAOG,IAAP,KAAiB,qBAArB,EAA2C;AACzCA,WAAQ,8BAAR;AACD;AACD,MAAI,CAACb,KAAKjB,IAAV,EAAgB;AACd,QAAM+B,UAAW,GAAED,IAAK,8CAAxB;AACA;AACA,QAAIE,QAAQC,GAAR,CAAYC,QAAZ,KAA0B,MAA9B,EAAqC;AACnCC,cAAQC,GAAR,CAAYC,gBAAMC,IAAN,CAAWC,GAAX,CAAeR,OAAf,CAAZ;AACAI,cAAQC,GAAR,CAAa,EAAb;AACAD,cAAQC,GAAR,CAAYnB,IAAZ;AACD,KAJD,MAIO;AACL,aAAOc,OAAP;AACD;AACDF,wBAAoB,IAApB;AACD;;AAED;AACA;AACA,MAAInC,EAAE8C,QAAF,CAAWvB,KAAKwB,OAAhB,CAAJ,EAA8B;AAC5B,QAAMC,iBAAiB,CACpB,MADoB,EAEpB,WAFoB,EAGpB,WAHoB,EAIpB,oBAJoB,EAKpB,sBALoB,EAMpB,mBANoB,CAAvB;AAQA,QAAMC,gBAAgBC,OAAOC,IAAP,CAAYnD,EAAEoD,IAAF,CAAO7B,KAAKwB,OAAZ,EAAqBC,cAArB,CAAZ,CAAtB;;AAEA,QAAMK,kBAAmB,GAAEjB,IAAK,yEAAhC;AACA,QAAMkB,gBAAiB,GAAElB,IAAK,wEAA9B;AACA,QAAIa,cAAc5B,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,UAAMkC,QAAS,GACbN,cAAc5B,MAAd,KAAyB,CAAzB,GAA6BgC,eAA7B,GAA+CC,aAChD;;EAELL,cAAchC,GAAd,CAAkB;AAAA,eAAM,QAAOuC,CAAE,GAAf;AAAA,OAAlB,EAAqCC,IAArC,CAA2C,IAA3C,CAAgD;;EAEhDC,KAAKC,SAAL,CAAepC,IAAf,EAAqB,IAArB,EAA2B,CAA3B,CAA8B;;;;;;;;;;;;;;;;EAgB9ByB,eAAe/B,GAAf,CAAmB;AAAA,eAAM,QAAOuC,CAAE,GAAf;AAAA,OAAnB,EAAsCC,IAAtC,CAA4C,IAA5C,CAAiD;;aAtB7C;AAyBA,UAAInB,QAAQC,GAAR,CAAYC,QAAZ,KAA0B,MAA9B,EAAqC;AACnC,eAAOe,KAAP;AACA;AACA;AACA;AACD,OALD,MAKO,IAAIN,cAAcW,IAAd,CAAmB;AAAA,eAAKrC,KAAKwB,OAAL,CAAaS,CAAb,MAAoBjC,KAAKiC,CAAL,CAAzB;AAAA,OAAnB,CAAJ,EAA0D;AAC/DpD,eAAOyD,KAAP,CAAaN,KAAb;AACD,OAFM,MAEA;AACL,YAAI,CAACzB,0BAA0BgC,GAA1B,CAA8BvC,KAAKwC,SAAnC,CAAL,EAAoD;AAClD3D,iBAAO4D,IAAP,CAAYT,KAAZ;AACAzB,oCAA0BmC,GAA1B,CAA8B1C,KAAKwC,SAAnC;AACD;AACF;AACF;AACF;;AAED;AACA;AACA,MAAIzB,QAAQC,GAAR,CAAYC,QAAZ,KAA0B,MAA9B,EAAqC;AACnC,QAAI,CAACjC,GAAG2D,UAAH,CAAc3C,KAAKwC,SAAnB,CAAL,EAAoC;AAClC,UAAM1B,WAAW,GAAED,IAAK,qDAAxB;AACAK,cAAQC,GAAR,CAAa,EAAb;AACAD,cAAQC,GAAR,CAAYC,gBAAMC,IAAN,CAAWC,GAAX,CAAeR,QAAf,CAAZ;AACAI,cAAQC,GAAR,CAAa,EAAb;AACAD,cAAQC,GAAR,CAAYnB,IAAZ;AACAY,0BAAoB,IAApB;AACD;AACF;;AAED,MAAI,CAACZ,KAAKwC,SAAN,IAAmB,CAACzD,KAAK6D,UAAL,CAAgB5C,KAAKwC,SAArB,CAAxB,EAAyD;AACvD,QAAM1B,YAAW,GAAED,IAAK,+EAAxB;AACA;AACA,QAAIE,QAAQC,GAAR,CAAYC,QAAZ,KAA0B,MAA9B,EAAqC;AACnCC,cAAQC,GAAR,CAAa,EAAb;AACAD,cAAQC,GAAR,CAAYC,gBAAMC,IAAN,CAAWC,GAAX,CAAeR,SAAf,CAAZ;AACAI,cAAQC,GAAR,CAAa,EAAb;AACAD,cAAQC,GAAR,CAAYnB,IAAZ;AACD,KALD,MAKO;AACL,aAAOc,SAAP;AACD;AACDF,wBAAoB,IAApB;AACD;;AAED,MAAIA,iBAAJ,EAAuB;AACrBM,YAAQC,GAAR,CAAa,EAAb;AACAD,YAAQC,GAAR,CACG,sGADH;AAGAD,YAAQC,GAAR,CAAa,EAAb;AACAJ,YAAQ8B,IAAR,CAAa,CAAb;AACD;;AAED,MAAIC,WAAY,GAAErE,EAAEsE,SAAF,CAAY/C,KAAKjB,IAAjB,CAAuB,OAAzC;AACA,MAAIiE,wBAAyB,YAAW7C,WAAWH,KAAKjB,IAAhB,CAAsB,EAA9D;;AAEA,MAAI+D,aAAc,OAAlB,EAA0B;AACxBA,eAAY,YAAZ;AACAE,4BAAyB,gBAAzB;AACD;AACD,MAAIC,SAASjD,KAAKiD,MAAL,IAAe,IAA5B;AACA;AACA,MACE,CAACA,MAAD,IACAnE,KAAKoE,IAAL,CACEjE,SAASI,MAAM8D,QAAN,GAAiBC,OAAjB,CAAyBC,SAAlC,EAA8C,qBAA9C,CADF,EAEEvD,MAJJ,EAKE;AACAmD,aAAU,OAAV;AACD;;AAED,MAAIK,eAAqB;AACvBL,UADuB;AAEvBH,YAFuB;AAGvBE,yBAHuB;AAIvBjE,UAAMiB,KAAKjB,IAJY;AAKvBwE,eAAWvD,KAAKuD,SALO;AAMvBf,eAAWxC,KAAKwC,SANO;AAOvBgB,wBAAoB,8CAA2BxD,KAAKwC,SAAhC,CAPG;AAQvB;AACAhB,aAASxB,KAAKwB,OAAL,IAAgB,EATF;AAUvBiC,eAAWC,KAAKC,GAAL;;AAGb;AAbyB,GAAzB,CAcA,IAAIL,aAAavE,IAAb,CAAkB,CAAlB,MAA0B,GAA9B,EAAkC;AAChCuE,iBAAavE,IAAb,GAAqB,IAAGuE,aAAavE,IAAK,EAA1C;AACD;;AAED,MAAM6E,SAASC,cAAIC,QAAJ,CAAaR,YAAb,EAA2B9E,WAAWuF,UAAtC,CAAf;AACA,MAAIH,OAAO5B,KAAX,EAAkB;AAChBd,YAAQC,GAAR,CAAYC,gBAAM4C,IAAN,CAAWC,QAAX,CAAqB,0CAArB,CAAZ;AACA/C,YAAQC,GAAR,CAAYC,gBAAMC,IAAN,CAAWC,GAAX,CAAesC,OAAO5B,KAAtB,CAAZ;AACAd,YAAQC,GAAR,CAAYmC,YAAZ;AACA,WAAO,IAAP;AACD;;AAED;AACA;AACA,MAAI,CAACA,aAAad,SAAb,CAAuB0B,QAAvB,CAAiC,UAAjC,CAAL,EAAkD;AAChD,QAAMC,cAAcnF,GAAGoF,YAAH,CAAgBd,aAAad,SAA7B,EAAyC,OAAzC,CAApB;AACA,QAAI6B,WAAW,IAAf;AACA,QAAIC,wBAAwB,IAA5B;;AAEA,QAAIH,gBAAiB,EAArB,EAAwB;AACtBE,iBAAW,KAAX;AACD;;AAED,QACE,CAACF,YAAYD,QAAZ,CAAsB,gBAAtB,CAAD,IACA,CAACC,YAAYD,QAAZ,CAAsB,gBAAtB,CADD,IAEA,CAACC,YAAYD,QAAZ,CAAsB,iBAAtB,CAHH,EAIE;AACAI,8BAAwB,KAAxB;AACD;AACD,QAAI,CAACD,QAAD,IAAa,CAACC,qBAAlB,EAAyC;AACvC,UAAMC,eAAexF,KAAKyF,QAAL,CACnBnF,MAAM8D,QAAN,GAAiBC,OAAjB,CAAyBC,SADN,EAEnBC,aAAad,SAFM,CAArB;;AAKA,UAAI,CAAC6B,QAAL,EAAe;AACbnD,gBAAQC,GAAR,CAAa,EAAb;AACAD,gBAAQC,GAAR,CACG,2DAA0DoD,YAAa,kDAD1E;AAGArD,gBAAQC,GAAR,CAAa,EAAb;AACA;AACA;AACD;;AAED,UAAI,CAACmD,qBAAL,EAA4B;AAC1BpD,gBAAQC,GAAR,CAAa,EAAb;AACAD,gBAAQC,GAAR,CACG,qEADH;AAGAD,gBAAQC,GAAR,CAAa,EAAb;AACD;;AAED;AACA;AACD;AACF;;AAED,SAAO;AACLlB,UAAO,aADF;AAELS,UAFK;AAGLC,WAHK;AAILT,aAASoD;AAJJ,GAAP;AAMD,CAjND;;AAmNA;;;;;;AAMAhE,QAAQmF,YAAR,GAAuB,UAACxB,MAAD,EAAiBvC,MAAjB,EAAqC;AAC1D,SAAO;AACLT,UAAO,eADF;AAELC,aAAS+C;AAFJ,GAAP;AAID,CALD;;AAOA;;;;;;;;;;;;;;;AAeA3D,QAAQoF,YAAR,GAAuB,UACrBzB,MADqB,EAErBvC,MAFqB,EAGrBC,OAHqB,EAIlB;AACH,MAAIgE,KAAK1B,OAAO0B,EAAP,IAAa5F,KAAK6F,KAAL,CAAW3B,OAAOT,SAAlB,EAA6B3B,IAAnD;AACA;AACA;AACA,MAAMgE,YAAa,YAAWF,EAAG,EAAjC;AACA,MAAIG,uBAAuB7F,SACzBI,MAAM8D,QAAN,GAAiBC,OAAjB,CAAyBC,SADA,EAExB,QAFwB,EAGxB,SAHwB,EAIxB,GAAEsB,EAAG,KAJmB,CAA3B;;AAOA,MAAII,iBAAyB;AAC3BJ,MAD2B;AAE3BE,aAF2B;AAG3BC,wBAH2B;AAI3BE,cAAU,IAJiB;AAK3BlC,cAAW,UAASrE,EAAEsE,SAAF,CAAY4B,EAAZ,CAAgB,OALT;AAM3B3B,2BAAwB,oBAAmB7C,WAAWwE,EAAX,CAAe,EAN/B;AAO3BnC,eAAWS,OAAOT,SAPS;AAQ3BgB,wBAAoB,8CAA2BP,OAAOT,SAAlC,CARO;AAS3B;AACAhB,aAASyB,OAAOzB,OAAP,IAAkB;AAVA,GAA7B;;AAaA,MAAMoC,SAASC,cAAIC,QAAJ,CAAaiB,cAAb,EAA6BvG,WAAWyG,YAAxC,CAAf;;AAEA,MAAIrB,OAAO5B,KAAX,EAAkB;AAChBd,YAAQC,GAAR,CACEC,gBAAM4C,IAAN,CAAWC,QAAX,CAAqB,4CAArB,CADF;AAGA/C,YAAQC,GAAR,CAAYC,gBAAMC,IAAN,CAAWC,GAAX,CAAesC,OAAO5B,KAAtB,CAAZ;AACAd,YAAQC,GAAR,CAAY4D,cAAZ;AACA,WAAO,IAAP;AACD;;AAED,SAAO;AACL9E,UAAO,eADF;AAELS,UAFK;AAGLC,WAHK;AAILT,aAAS6E;AAJJ,GAAP;AAMD,CA9CD;;AAgDA;;;;;;;AAOAzF,QAAQ4F,UAAR,GAAqB,UAACC,MAAD,EAAiBC,IAAjB,EAA4B1E,MAA5B,EAA+C;AAClE,MAAI2E,iCAAJ;AACA;AACA;AACA,MAAID,IAAJ,EAAU;AACR;AACA,QAAME,kBAAkB/F,wBAAwB6F,KAAK5F,QAA7B,CAAxB;AACA,QAAI8F,gBAAgBxF,MAAhB,GAAyB,CAA7B,EAAgC;AAC9BuF,iCAA2BC,gBAAgB5F,GAAhB,CAAoB;AAAA,eAC7CJ,QAAQ4F,UAAR,CAAmBK,CAAnB,EAAsBpG,QAAQoG,CAAR,CAAtB,EAAkC7E,MAAlC,CAD6C;AAAA,OAApB,CAA3B;AAGD;AACF;;AAED,MAAM8E,eAAe;AACnBvF,UAAO,aADY;AAEnBS,UAFmB;AAGnB0E,QAHmB;AAInBlF,aAASiF;AAJU,GAArB;;AAOA,MAAIE,wBAAJ,EAA8B;AAC5B,qBAAWA,wBAAX,GAAqCG,YAArC;AACD,GAFD,MAEO;AACL,WAAOA,YAAP;AACD;AACF,CA1BD;;AA4BA;;;;;;AAMAlG,QAAQmG,WAAR,GAAsB,UAACC,KAAD,EAAehF,MAAf,EAAkC;AACtD;AACA,MAAM4E,kBAAkB7G,EAAEkH,OAAF,CACtBD,MAAMhG,GAAN,CAAU;AAAA,WAAKH,wBAAwBJ,QAAQoG,CAAR,EAAW/F,QAAnC,CAAL;AAAA,GAAV,CADsB,CAAxB;AAGA,MAAI6F,iCAAJ;AACA,MAAIC,gBAAgBxF,MAAhB,GAAyB,CAA7B,EAAgC;AAC9BuF,+BAA2BC,gBAAgB5F,GAAhB,CAAoB;AAAA,aAC7CJ,QAAQ4F,UAAR,CAAmBK,CAAnB,EAAsBpG,QAAQoG,CAAR,CAAtB,EAAkC7E,MAAlC,CAD6C;AAAA,KAApB,CAA3B;AAGD;;AAED,MAAMkF,oBAAoB;AACxB3F,UAAO,cADiB;AAExBS,UAFwB;AAGxBR,aAASwF;AAHe,GAA1B;;AAMA,MAAIL,wBAAJ,EAA8B;AAC5B,qBAAWA,wBAAX,GAAqCO,iBAArC;AACD,GAFD,MAEO;AACL,WAAOA,iBAAP;AACD;AACF,CAvBD;;AAyBA,IAAMC,aAAa,EAAnB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DAvG,QAAQwG,UAAR,GAAqB,UAACV,IAAD,EAAY1E,MAAZ,EAA6BC,OAA7B,EAAkD;AACrE,MAAI,CAAClC,EAAE8C,QAAF,CAAW6D,IAAX,CAAL,EAAuB;AACrB,WAAOlE,QAAQC,GAAR,CACLC,gBAAMC,IAAN,CAAWC,GAAX,CACG,sEADH,CADK,CAAP;AAKD;;AAED;AACA,MAAI,CAAC8D,KAAKW,QAAV,EAAoB;AAClBX,SAAKW,QAAL,GAAgB,EAAhB;AACD;;AAED;AACA,MAAIX,KAAKW,QAAL,CAAcC,KAAlB,EAAyB;AACvB9E,YAAQC,GAAR,CAAYgB,KAAKC,SAAL,CAAegD,IAAf,EAAqB,IAArB,EAA2B,CAA3B,CAAZ;AACAlE,YAAQC,GAAR,CACEC,gBAAMC,IAAN,CAAWC,GAAX,CACG,gFADH,CADF;AAKAP,YAAQ8B,IAAR,CAAa,CAAb;AACD;;AAED;AACA,MAAInC,MAAJ,EAAY;AACV0E,SAAKW,QAAL,CAAcC,KAAd,GAAsBtF,OAAOG,IAA7B;AACD;;AAED,MAAM+C,SAASC,cAAIC,QAAJ,CAAasB,IAAb,EAAmB5G,WAAWyH,UAA9B,CAAf;AACA,MAAIrC,OAAO5B,KAAX,EAAkB;AAChBd,YAAQC,GAAR,CAAYC,gBAAMC,IAAN,CAAWC,GAAX,CAAgB,qCAAhB,CAAZ;AACAJ,YAAQC,GAAR,CAAYC,gBAAMC,IAAN,CAAWC,GAAX,CAAesC,OAAO5B,KAAtB,CAAZ;AACAd,YAAQC,GAAR,CAAYiE,IAAZ;AACA,WAAO,EAAEnF,MAAO,kBAAT,EAA4B+B,OAAO,IAAnC,EAAP;AACD;;AAED;AACA,MAAIoD,KAAKc,MAAT,EAAiB;AACf,UAAM,IAAIC,KAAJ,CACJvH,WAAY;;;;;;;;;QASVuD,KAAKC,SAAL,CAAegD,IAAf,EAAqB,IAArB,EAA2B,CAA3B,CAA8B;;;;QAI9BjD,KAAKC,SAAL,CAAe1B,MAAf,EAAuB,IAAvB,EAA6B,CAA7B,CAAgC;KAd9B,CAAN;AAiBD;;AAEDtB,+BAA6BgG,IAA7B;;AAEA,MAAMgB,UAAUjH,QAAQiG,KAAKT,EAAb,CAAhB;;AAEA;AACA;AACA,MAAIjE,MAAJ,EAAY;AACV,QAAI2F,aAAa3F,OAAOG,IAAxB;;AAEA,QAAI,CAACgF,WAAWT,KAAKW,QAAL,CAAc9F,IAAzB,CAAL,EACE4F,WAAWT,KAAKW,QAAL,CAAc9F,IAAzB,IAAiCoG,UAAjC,CADF,KAEK,IAAIR,WAAWT,KAAKW,QAAL,CAAc9F,IAAzB,MAAmCoG,UAAvC,EACH,MAAM,IAAIF,KAAJ,CAAUvH,WAAY;sBACZyH,UAAW;;yBAERjB,KAAKW,QAAL,CAAc9F,IAAK,kBACpC4F,WAAWT,KAAKW,QAAL,CAAc9F,IAAzB,CACD;;;;;;;UAOGkC,KAAKC,SAAL,CAAegD,IAAf,EAAqB,IAArB,EAA2B,CAA3B,CAA8B;;;;UAI9BjD,KAAKC,SAAL,CAAe1B,MAAf,EAAuB,IAAvB,EAA6B,CAA7B,CAAgC;OAhB9B,CAAN;;AAmBF;AACA;AACA,QAAI0F,WAAWA,QAAQL,QAAR,CAAiBC,KAAjB,KAA2BK,UAA1C,EAAsD;AACpD,YAAM,IAAIF,KAAJ,CACJvH,WAAY;0DACsCwG,KAAKT,EAAG;oBAC9CyB,QAAQL,QAAR,CAAiBC,KAAM,yBAAwBK,UAAW;;;SAHlE,CAAN;AAQD;AACF;;AAED,MAAIb,qBAAJ;AACA,MAAIc,yBAAJ;AACA;AACA,MAAIF,WAAW,CAAClH,eAAekG,KAAKT,EAApB,EAAwBS,KAAKW,QAAL,CAAcQ,aAAtC,CAAhB,EAAsE;AACpED,uBAAmB;AACjBrG,YAAO,YADU;AAEjBS,YAFiB;AAGjBC,aAHiB;AAIjBT,eAASkF,KAAKT;AAJG,KAAnB;AAMD,GAPD,MAOO;AACL;AACA;AACA,QAAIyB,OAAJ,EAAa;AACX,UAAMd,kBAAkB/F,wBAAwB6G,QAAQ5G,QAAhC,CAAxB;AACA,UAAI8F,gBAAgBxF,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B0F,uBAAelG,QAAQmG,WAAR,CAAoBH,eAApB,CAAf;AACD;AACF;;AAEDgB,uBAAmB;AACjBrG,YAAO,aADU;AAEjBS,YAFiB;AAGjBC,aAHiB;AAIjBT,eAASkF;AAJQ,KAAnB;AAMD;;AAED,MAAII,YAAJ,EAAkB;AAChB,WAAO,CAACA,YAAD,EAAec,gBAAf,CAAP;AACD,GAFD,MAEO;AACL,WAAOA,gBAAP;AACD;AACF,CAzID;;AA2IA;;;;;;;;;;AAUAhH,QAAQkH,SAAR,GAAoB,UAACrB,MAAD,EAAiBzE,MAAjB,EAAqC;AACvD,SAAO;AACLT,UAAO,YADF;AAELS,UAFK;AAGLR,aAASiF;AAHJ,GAAP;AAKD,CAND;;AAeA;;;;;;;;;;;;;;;;;;;;;;AAsBA7F,QAAQmH,eAAR,GAA0B,gBAExB/F,MAFwB,EAGxBC,OAHwB,EAIrB;AAAA,MAHDyE,IAGC,QAHDA,IAGC;AAAA,MAHKvE,IAGL,QAHKA,IAGL;AAAA,MAHW6F,KAGX,QAHWA,KAGX;AAAA,MAHkBC,SAGlB,QAHkBA,SAGlB;AAAA,MAH6BC,UAG7B,QAH6BA,UAG7B;;AACH,MAAID,SAAJ,EAAe;AACbzF,YAAQuB,IAAR,CACG,8EADH;AAGA,QAAI,CAAC5B,IAAL,EAAW;AACTA,aAAO8F,SAAP;AACD;AACF;AACD,MAAIC,UAAJ,EAAgB;AACd1F,YAAQuB,IAAR,CACG,gFADH;AAGA,QAAI,CAACiE,KAAL,EAAY;AACVA,cAAQE,UAAR;AACD;AACF;AACD;AACA,MAAI,CAACxB,KAAKW,QAAL,CAAcc,WAAnB,EAAgC;AAC9BzB,SAAKW,QAAL,CAAcc,WAAd,GAA4B,EAA5B;AACD;AACD,MAAI,CAACzB,KAAKc,MAAV,EAAkB;AAChBd,SAAKc,MAAL,GAAc,EAAd;AACD;;AAED;;;AAGA,MAAMY,kBAAkBrI,EAAEyF,QAAF,CAAWrD,IAAX,EAAkB,SAAlB,IACpBA,KAAKkG,KAAL,CAAY,KAAZ,EAAkB,CAAlB,CADoB,GAEpBlG,IAFJ;;AAIA;AACA,MAAMmG,aAAa5B,KAAKW,QAAL,CAAcc,WAAd,CAA0BC,eAA1B,CAAnB;AACA,MAAIE,cAAcA,eAAetG,OAAOG,IAAxC,EAA8C;AAC5C,UAAM,IAAIsF,KAAJ,CACJvH,WAAY;;;iBAGDwG,KAAKT,EAAG;gBACTjE,OAAOG,IAAK;cACdA,IAAK;eACJ6F,KAAM;OAPX,CAAN;AAUD;;AAED;AACAtB,OAAKc,MAAL,CAAYrF,IAAZ,IAAoB6F,KAApB;AACAtB,OAAKW,QAAL,CAAcc,WAAd,CAA0BC,eAA1B,IAA6CpG,OAAOG,IAApD;;AAEA,SAAO;AACLZ,UAAO,mBADF;AAELS,UAFK;AAGLC,WAHK;AAILT,aAASkF;AAJJ,GAAP;AAMD,CA7DD;;AA+DA;;;;;;;;;;;;AAYA9F,QAAQ2H,qBAAR,GAAgC,iBAE9BvG,MAF8B,EAG3B;AAAA,MAFDwG,MAEC,SAFDA,MAEC;AAAA,MAFOtH,KAEP,SAFOA,KAEP;;AACH;AACAsH,SAAO1H,QAAP,CAAgB2H,IAAhB,CAAqBvH,MAAM+E,EAA3B;AACAuC,SAAO1H,QAAP,GAAkBf,EAAE2I,IAAF,CAAOF,OAAO1H,QAAd,CAAlB;;AAEA,SAAO;AACLS,UAAO,+BADF;AAELS,UAFK;AAGLR,aAASgH;AAHJ,GAAP;AAKD,CAbD;;AAeA;;;;;;;;;AASA5H,QAAQ+H,oBAAR,GAA+B,iBAO1B;AAAA,MALDtI,IAKC,SALDA,IAKC;AAAA,MAJDoG,MAIC,SAJDA,MAIC;AAAA,MAHDmC,UAGC,SAHDA,UAGC;AAAA,MADH5G,MACG,uEADe,EACf;;AACH,SAAO;AACLT,UAAO,6BADF;AAELS,UAFK;AAGLR,aAAS;AACPnB,UADO;AAEPoG,YAFO;AAGPmC;AAHO;AAHJ,GAAP;AASD,CAjBD;;AAmBA;;;;;;AAMAhI,QAAQiI,4BAAR,GAAuC,UAACC,KAAD,EAAqB;AAC1D,SAAO;AACLvH,UAAO,gCADF;AAELC,aAAS;AACPsH;AADO;AAFJ,GAAP;AAMD,CAPD;;AASA;;;;;AAKAlI,QAAQmI,qBAAR,GAAgC,iBAM1B;AAAA,MALJC,KAKI,SALJA,KAKI;AAAA,MAJJC,aAII,SAJJA,aAII;;AACJ,SAAO;AACL1H,UAAO,yBADF;AAELC,aAAS;AACPwH,WADO;AAEPC;AAFO;AAFJ,GAAP;AAOD,CAdD;;AAgBA;;;;;;;;;;;;AAYArI,QAAQsI,SAAR,GAAoB,UAACC,GAAD,EAAuC;AAAA,MAA5BnH,MAA4B,uEAAT,IAAS;;AACzD,SAAO;AACLT,UAAO,YADF;AAELS,UAFK;AAGLR,aAAS2H;AAHJ,GAAP;AAKD,CAND;;AAQA;;;;;;;;;AASAvI,QAAQwI,MAAR,GAAiB,UAACD,GAAD,EAAuC;AAAA,MAA5BnH,MAA4B,uEAAT,IAAS;;AACtD,SAAO;AACLT,UAAO,SADF;AAELS,UAFK;AAGLR,aAAS2H;AAHJ,GAAP;AAKD,CAND;;AAQA;;;;;;;;;AASAvI,QAAQyI,MAAR,GAAiB,UAACF,GAAD,EAAuC;AAAA,MAA5BnH,MAA4B,uEAAT,IAAS;;AACtD,SAAO;AACLT,UAAO,SADF;AAELS,UAFK;AAGLR,aAAS2H;AAHJ,GAAP;AAKD,CAND;;AAQA;;;;;;;;AAQAvI,QAAQ0I,eAAR,GAA0B,UACxBC,MADwB,EAExBvH,MAFwB,EAGrB;AACH,SAAO;AACLT,UAAO,mBADF;AAELS,UAFK;AAGLR,aAAS+H;AAHJ,GAAP;AAKD,CATD;;AAWA;;;;;;;;;;;;;;;AAeA3I,QAAQ4I,cAAR,GAAyB,iBAMnB;AAAA,MALJC,QAKI,SALJA,QAKI;AAAA,gCAJJC,WAII;AAAA,MAJJA,WAII,qCAJU,KAIV;AAAA,oCAHJC,iBAGI;AAAA,MAHJA,iBAGI,yCAHgB,KAGhB;AAAA,MAFJC,MAEI,SAFJA,MAEI;AAAA,MADDC,IACC;;AACJ,MAAIC,aAAc,EAAlB;AACA,MAAInJ,MAAM8D,QAAN,GAAiBC,OAAjB,CAAyBqF,WAA7B,EAA0C;AACxCD,iBAAanJ,MAAM8D,QAAN,GAAiBuF,MAAjB,CAAwBF,UAArC;AACD;;AAED,SAAO;AACLvI,UAAO,iBADF;AAELC;AACEiI,gBAAW,GAAEK,UAAW,GAAEL,QAAS,EADrC;AAEEC,iBAFF;AAGEC,uBAHF;AAIEC,cAAS,GAAEE,UAAW,GAAEF,MAAO;AAJjC,OAKKC,IALL;AAFK,GAAP;AAUD,CAtBD;;AAwBA;;;AAGAI,QAAQrJ,OAAR,GAAkBA,OAAlB;;AAEA;;;AAGAqJ,QAAQC,mBAAR,GAA8BjK,mBAAmBW,OAAnB,EAA4BD,MAAMwJ,QAAlC,CAA9B","file":"actions.js","sourcesContent":["// @flow\nimport Joi from \"joi\"\nimport chalk from \"chalk\"\nconst _ = require(`lodash`)\nconst { bindActionCreators } = require(`redux`)\nconst { stripIndent } = require(`common-tags`)\nconst report = require(`gatsby-cli/lib/reporter`)\nconst glob = require(`glob`)\nconst path = require(`path`)\nconst fs = require(`fs`)\nconst { joinPath } = require(`../utils/path`)\nconst { hasNodeChanged, getNode } = require(`./index`)\nconst { trackInlineObjectsInRootNode } = require(`../schema/node-tracking`)\nconst { store } = require(`./index`)\nimport * as joiSchemas from \"../joi-schemas/joi\"\nimport { generateComponentChunkName } from \"../utils/js-chunk-names\"\n\nconst actions = {}\n\nconst findChildrenRecursively = (children = []) => {\n  children = children.concat(\n    ...children.map(child => {\n      const newChildren = getNode(child).children\n      if (_.isArray(newChildren) && newChildren.length > 0) {\n        return findChildrenRecursively(newChildren)\n      } else {\n        return []\n      }\n    })\n  )\n\n  return children\n}\n\ntype Job = {\n  id: string,\n}\ntype PageInput = {\n  path: string,\n  component: string,\n  layout?: string,\n  context?: Object,\n}\ntype LayoutInput = {\n  id?: string,\n  machineId?: string,\n  component: string,\n  layout?: string,\n  context?: Object,\n}\n\ntype Page = {\n  path: string,\n  matchPath: ?string,\n  component: string,\n  context: Object,\n  internalComponentName: string,\n  jsonName: string,\n  componentChunkName: string,\n  layout: ?string,\n  updatedAt: number,\n}\n\ntype Layout = {\n  id: any,\n  context: Object,\n  component: string,\n  componentWrapperPath: string,\n  componentChunkName: string,\n  internalComponentName: string,\n  jsonName: string,\n  isLayout: true,\n}\n\ntype Plugin = {\n  name: string,\n}\n\n/**\n * Delete a page\n * @param {Object} page a page object with at least the path set\n * @param {string} page.path The path of the page\n * @param {string} page.component The absolute path to the page component\n * @example\n * deletePage(page)\n */\nactions.deletePage = (page: PageInput) => {\n  return {\n    type: `DELETE_PAGE`,\n    payload: page,\n  }\n}\n\nconst pascalCase = _.flow(\n  _.camelCase,\n  _.upperFirst\n)\nconst hasWarnedForPageComponent = new Set()\n/**\n * Create a page. See [the guide on creating and modifying pages](/docs/creating-and-modifying-pages/)\n * for detailed documenation about creating pages.\n * @param {Object} page a page object\n * @param {string} page.path Any valid URL. Must start with a forward slash\n * @param {string} page.component The absolute path to the component for this page\n * @param {string} page.layout The name of the layout for this page. By default\n * `'index'` layout is used\n * @param {Object} page.context Context data for this page. Passed as props\n * to the component `this.props.pathContext` as well as to the graphql query\n * as graphql arguments.\n * @example\n * createPage({\n *   path: `/my-sweet-new-page/`,\n *   component: path.resolve(`./src/templates/my-sweet-new-page.js`),\n *   // If you have a layout component at src/layouts/blog-layout.js\n *   layout: `blog-layout`,\n *   // The context is passed as props to the component as well\n *   // as into the component's GraphQL query.\n *   context: {\n *     id: `123456`,\n *   },\n * })\n */\nactions.createPage = (page: PageInput, plugin?: Plugin, traceId?: string) => {\n  let noPageOrComponent = false\n  let name = `The plugin \"${plugin.name}\"`\n  if (plugin.name === `default-site-plugin`) {\n    name = `Your site's \"gatsby-node.js\"`\n  }\n  if (!page.path) {\n    const message = `${name} must set the page path when creating a page`\n    // Don't log out when testing\n    if (process.env.NODE_ENV !== `test`) {\n      console.log(chalk.bold.red(message))\n      console.log(``)\n      console.log(page)\n    } else {\n      return message\n    }\n    noPageOrComponent = true\n  }\n\n  // Validate that the context object doesn't overlap with any core page fields\n  // as this will cause trouble when running graphql queries.\n  if (_.isObject(page.context)) {\n    const reservedFields = [\n      `path`,\n      `matchPath`,\n      `component`,\n      `componentChunkName`,\n      `pluginCreator___NODE`,\n      `pluginCreatorName`,\n    ]\n    const invalidFields = Object.keys(_.pick(page.context, reservedFields))\n\n    const singularMessage = `${name} used a reserved field name in the context object when creating a page:`\n    const pluralMessage = `${name} used reserved field names in the context object when creating a page:`\n    if (invalidFields.length > 0) {\n      const error = `${\n        invalidFields.length === 1 ? singularMessage : pluralMessage\n      }\n\n${invalidFields.map(f => `  * \"${f}\"`).join(`\\n`)}\n\n${JSON.stringify(page, null, 4)}\n\nData in \"context\" is passed to GraphQL as potential arguments when running the\npage query.\n\nWhen arguments for GraphQL are constructed, the context object is combined with\nthe page object so *both* page object and context data are available as\narguments. So you don't need to add the page \"path\" to the context as it's\nalready available in GraphQL. If a context field duplicates a field already\nused by the page object, this can break functionality within Gatsby so must be\navoided.\n\nPlease choose another name for the conflicting fields.\n\nThe following fields are used by the page object and should be avoided.\n\n${reservedFields.map(f => `  * \"${f}\"`).join(`\\n`)}\n\n            `\n      if (process.env.NODE_ENV === `test`) {\n        return error\n        // Only error if the context version is different than the page\n        // version.  People in v1 often thought that they needed to also pass\n        // the path to context for it to be available in GraphQL\n      } else if (invalidFields.some(f => page.context[f] !== page[f])) {\n        report.panic(error)\n      } else {\n        if (!hasWarnedForPageComponent.has(page.component)) {\n          report.warn(error)\n          hasWarnedForPageComponent.add(page.component)\n        }\n      }\n    }\n  }\n\n  // Don't check if the component exists during tests as we use a lot of fake\n  // component paths.\n  if (process.env.NODE_ENV !== `test`) {\n    if (!fs.existsSync(page.component)) {\n      const message = `${name} created a page with a component that doesn't exist`\n      console.log(``)\n      console.log(chalk.bold.red(message))\n      console.log(``)\n      console.log(page)\n      noPageOrComponent = true\n    }\n  }\n\n  if (!page.component || !path.isAbsolute(page.component)) {\n    const message = `${name} must set the absolute path to the page component when create creating a page`\n    // Don't log out when testing\n    if (process.env.NODE_ENV !== `test`) {\n      console.log(``)\n      console.log(chalk.bold.red(message))\n      console.log(``)\n      console.log(page)\n    } else {\n      return message\n    }\n    noPageOrComponent = true\n  }\n\n  if (noPageOrComponent) {\n    console.log(``)\n    console.log(\n      `See the documentation for createPage https://www.gatsbyjs.org/docs/bound-action-creators/#createPage`\n    )\n    console.log(``)\n    process.exit(1)\n  }\n\n  let jsonName = `${_.kebabCase(page.path)}.json`\n  let internalComponentName = `Component${pascalCase(page.path)}`\n\n  if (jsonName === `.json`) {\n    jsonName = `index.json`\n    internalComponentName = `ComponentIndex`\n  }\n  let layout = page.layout || null\n  // If no layout is set we try fallback to `/src/layouts/index`.\n  if (\n    !layout &&\n    glob.sync(\n      joinPath(store.getState().program.directory, `src/layouts/index.*`)\n    ).length\n  ) {\n    layout = `index`\n  }\n\n  let internalPage: Page = {\n    layout,\n    jsonName,\n    internalComponentName,\n    path: page.path,\n    matchPath: page.matchPath,\n    component: page.component,\n    componentChunkName: generateComponentChunkName(page.component),\n    // Ensure the page has a context object\n    context: page.context || {},\n    updatedAt: Date.now(),\n  }\n\n  // If the path doesn't have an initial forward slash, add it.\n  if (internalPage.path[0] !== `/`) {\n    internalPage.path = `/${internalPage.path}`\n  }\n\n  const result = Joi.validate(internalPage, joiSchemas.pageSchema)\n  if (result.error) {\n    console.log(chalk.blue.bgYellow(`The upserted page didn't pass validation`))\n    console.log(chalk.bold.red(result.error))\n    console.log(internalPage)\n    return null\n  }\n\n  // Validate that the page component imports React and exports something\n  // (hopefully a component).\n  if (!internalPage.component.includes(`/.cache/`)) {\n    const fileContent = fs.readFileSync(internalPage.component, `utf-8`)\n    let notEmpty = true\n    let includesDefaultExport = true\n\n    if (fileContent === ``) {\n      notEmpty = false\n    }\n\n    if (\n      !fileContent.includes(`export default`) &&\n      !fileContent.includes(`module.exports`) &&\n      !fileContent.includes(`exports.default`)\n    ) {\n      includesDefaultExport = false\n    }\n    if (!notEmpty || !includesDefaultExport) {\n      const relativePath = path.relative(\n        store.getState().program.directory,\n        internalPage.component\n      )\n\n      if (!notEmpty) {\n        console.log(``)\n        console.log(\n          `You have an empty file in the \"src/pages\" directory at \"${relativePath}\". Please remove it or make it a valid component`\n        )\n        console.log(``)\n        // TODO actually do die during builds.\n        // process.exit(1)\n      }\n\n      if (!includesDefaultExport) {\n        console.log(``)\n        console.log(\n          `The page component must export a React component for it to be valid`\n        )\n        console.log(``)\n      }\n\n      // TODO actually do die during builds.\n      // process.exit(1)\n    }\n  }\n\n  return {\n    type: `CREATE_PAGE`,\n    plugin,\n    traceId,\n    payload: internalPage,\n  }\n}\n\n/**\n * Delete a layout\n * @param {string} layout a layout object with at least the name set\n * @example\n * deleteLayout(layout)\n */\nactions.deleteLayout = (layout: Layout, plugin?: Plugin) => {\n  return {\n    type: `DELETE_LAYOUT`,\n    payload: layout,\n  }\n}\n\n/**\n * Create a layout. Generally layouts are created automatically by placing a\n * React component in the `src/layouts/` directory. This action should be used\n * if loading layouts from an NPM package or from a non-standard location.\n * @param {Object} layout a layout object\n * @param {string} layout.component The absolute path to the component for this layout\n * @example\n * createLayout({\n *   component: path.resolve(`./src/templates/myNewLayout.js`),\n *   id: 'custom-id', // If no id is provided, the filename will be used as id.\n *   context: {\n *     title: `My New Layout`\n *   }\n * })\n */\nactions.createLayout = (\n  layout: LayoutInput,\n  plugin?: Plugin,\n  traceId?: string\n) => {\n  let id = layout.id || path.parse(layout.component).name\n  // Add a \"machine\" id as a universal ID to differentiate layout from\n  // page components.\n  const machineId = `layout---${id}`\n  let componentWrapperPath = joinPath(\n    store.getState().program.directory,\n    `.cache`,\n    `layouts`,\n    `${id}.js`\n  )\n\n  let internalLayout: Layout = {\n    id,\n    machineId,\n    componentWrapperPath,\n    isLayout: true,\n    jsonName: `layout-${_.kebabCase(id)}.json`,\n    internalComponentName: `Component-layout-${pascalCase(id)}`,\n    component: layout.component,\n    componentChunkName: generateComponentChunkName(layout.component),\n    // Ensure the page has a context object\n    context: layout.context || {},\n  }\n\n  const result = Joi.validate(internalLayout, joiSchemas.layoutSchema)\n\n  if (result.error) {\n    console.log(\n      chalk.blue.bgYellow(`The upserted layout didn't pass validation`)\n    )\n    console.log(chalk.bold.red(result.error))\n    console.log(internalLayout)\n    return null\n  }\n\n  return {\n    type: `CREATE_LAYOUT`,\n    plugin,\n    traceId,\n    payload: internalLayout,\n  }\n}\n\n/**\n * Delete a node\n * @param {string} nodeId a node id\n * @param {object} node the node object\n * @example\n * deleteNode(node.id, node)\n */\nactions.deleteNode = (nodeId: string, node: any, plugin: Plugin) => {\n  let deleteDescendantsActions\n  // It's possible the file node was never created as sometimes tools will\n  // write and then immediately delete temporary files to the file system.\n  if (node) {\n    // Also delete any nodes transformed from this one.\n    const descendantNodes = findChildrenRecursively(node.children)\n    if (descendantNodes.length > 0) {\n      deleteDescendantsActions = descendantNodes.map(n =>\n        actions.deleteNode(n, getNode(n), plugin)\n      )\n    }\n  }\n\n  const deleteAction = {\n    type: `DELETE_NODE`,\n    plugin,\n    node,\n    payload: nodeId,\n  }\n\n  if (deleteDescendantsActions) {\n    return [...deleteDescendantsActions, deleteAction]\n  } else {\n    return deleteAction\n  }\n}\n\n/**\n * Batch delete nodes\n * @param {Array} nodes an array of node ids\n * @example\n * deleteNodes([`node1`, `node2`])\n */\nactions.deleteNodes = (nodes: any[], plugin: Plugin) => {\n  // Also delete any nodes transformed from these.\n  const descendantNodes = _.flatten(\n    nodes.map(n => findChildrenRecursively(getNode(n).children))\n  )\n  let deleteDescendantsActions\n  if (descendantNodes.length > 0) {\n    deleteDescendantsActions = descendantNodes.map(n =>\n      actions.deleteNode(n, getNode(n), plugin)\n    )\n  }\n\n  const deleteNodesAction = {\n    type: `DELETE_NODES`,\n    plugin,\n    payload: nodes,\n  }\n\n  if (deleteDescendantsActions) {\n    return [...deleteDescendantsActions, deleteNodesAction]\n  } else {\n    return deleteNodesAction\n  }\n}\n\nconst typeOwners = {}\n/**\n * Create a new node.\n * @param {Object} node a node object\n * @param {string} node.id The node's ID. Must be globally unique.\n * @param {string} node.parent The ID of the parent's node. If the node is\n * derived from another node, set that node as the parent. Otherwise it can\n * just be `null`.\n * @param {Array} node.children An array of children node IDs. If you're\n * creating the children nodes while creating the parent node, add the\n * children node IDs here directly. If you're adding a child node to a\n * parent node created by a plugin, you can't mutate this value directly\n * to add your node id, instead use the action creator `createParentChildLink`.\n * @param {Object} node.internal node fields that aren't generally\n * interesting to consumers of node data but are very useful for plugin writers\n * and Gatsby core.\n * @param {string} node.internal.mediaType An optional field to indicate to\n * transformer plugins that your node has raw content they can transform.\n * Use either an official media type (we use mime-db as our source\n * (https://www.npmjs.com/package/mime-db) or a made-up one if your data\n * doesn't fit in any existing bucket. Transformer plugins use node media types\n * for deciding if they should transform a node into a new one. E.g.\n * markdown transformers look for media types of\n * `text/markdown`.\n * @param {string} node.internal.type An arbitrary globally unique type\n * choosen by the plugin creating the node. Should be descriptive of the\n * node as the type is used in forming GraphQL types so users will query\n * for nodes based on the type choosen here. Nodes of a given type can\n * only be created by one plugin.\n * @param {string} node.internal.content An optional field. The raw content\n * of the node. Can be excluded if it'd require a lot of memory to load in\n * which case you must define a `loadNodeContent` function for this node.\n * @param {string} node.internal.contentDigest the digest for the content\n * of this node. Helps Gatsby avoid doing extra work on data that hasn't\n * changed.\n * @param {string} node.internal.description An optional field. Human\n * readable description of what this node represent / its source. It will\n * be displayed when type conflicts are found, making it easier to find\n * and correct type conflicts.\n * @example\n * createNode({\n *   // Data for the node.\n *   field1: `a string`,\n *   field2: 10,\n *   field3: true,\n *   ...arbitraryOtherData,\n *\n *   // Required fields.\n *   id: `a-node-id`,\n *   parent: `the-id-of-the-parent-node`, // or null if it's a source node without a parent\n *   children: [],\n *   internal: {\n *     type: `CoolServiceMarkdownField`,\n *     contentDigest: crypto\n *       .createHash(`md5`)\n *       .update(JSON.stringify(fieldData))\n *       .digest(`hex`),\n *     mediaType: `text/markdown`, // optional\n *     content: JSON.stringify(fieldData), // optional\n *     description: `Cool Service: \"Title of entry\"`, // optional\n *   }\n * })\n */\nactions.createNode = (node: any, plugin?: Plugin, traceId?: string) => {\n  if (!_.isObject(node)) {\n    return console.log(\n      chalk.bold.red(\n        `The node passed to the \"createNode\" action creator must be an object`\n      )\n    )\n  }\n\n  // Ensure the new node has an internals object.\n  if (!node.internal) {\n    node.internal = {}\n  }\n\n  // Tell user not to set the owner name themself.\n  if (node.internal.owner) {\n    console.log(JSON.stringify(node, null, 4))\n    console.log(\n      chalk.bold.red(\n        `The node internal.owner field is set automatically by Gatsby and not by plugin`\n      )\n    )\n    process.exit(1)\n  }\n\n  // Add the plugin name to the internal object.\n  if (plugin) {\n    node.internal.owner = plugin.name\n  }\n\n  const result = Joi.validate(node, joiSchemas.nodeSchema)\n  if (result.error) {\n    console.log(chalk.bold.red(`The new node didn't pass validation`))\n    console.log(chalk.bold.red(result.error))\n    console.log(node)\n    return { type: `VALIDATION_ERROR`, error: true }\n  }\n\n  // Ensure node isn't directly setting fields.\n  if (node.fields) {\n    throw new Error(\n      stripIndent`\n      Plugins creating nodes can not set data on the reserved field \"fields\"\n      as this is reserved for plugins which wish to extend your nodes.\n\n      If your plugin didn't add \"fields\" you're probably seeing this\n      error because you're reusing an old node object.\n\n      Node:\n\n      ${JSON.stringify(node, null, 4)}\n\n      Plugin that created the node:\n\n      ${JSON.stringify(plugin, null, 4)}\n    `\n    )\n  }\n\n  trackInlineObjectsInRootNode(node)\n\n  const oldNode = getNode(node.id)\n\n  // Ensure the plugin isn't creating a node type owned by another\n  // plugin. Type \"ownership\" is first come first served.\n  if (plugin) {\n    let pluginName = plugin.name\n\n    if (!typeOwners[node.internal.type])\n      typeOwners[node.internal.type] = pluginName\n    else if (typeOwners[node.internal.type] !== pluginName)\n      throw new Error(stripIndent`\n        The plugin \"${pluginName}\" created a node of a type owned by another plugin.\n\n        The node type \"${node.internal.type}\" is owned by \"${\n        typeOwners[node.internal.type]\n      }\".\n\n        If you copy and pasted code from elsewhere, you'll need to pick a new type name\n        for your new node(s).\n\n        The node object passed to \"createNode\":\n\n        ${JSON.stringify(node, null, 4)}\n\n        The plugin creating the node:\n\n        ${JSON.stringify(plugin, null, 4)}\n      `)\n\n    // If the node has been created in the past, check that\n    // the current plugin is the same as the previous.\n    if (oldNode && oldNode.internal.owner !== pluginName) {\n      throw new Error(\n        stripIndent`\n        Nodes can only be updated by their owner. Node \"${node.id}\" is\n        owned by \"${oldNode.internal.owner}\" and another plugin \"${pluginName}\"\n        tried to update it.\n\n        `\n      )\n    }\n  }\n\n  let deleteAction\n  let updateNodeAction\n  // Check if the node has already been processed.\n  if (oldNode && !hasNodeChanged(node.id, node.internal.contentDigest)) {\n    updateNodeAction = {\n      type: `TOUCH_NODE`,\n      plugin,\n      traceId,\n      payload: node.id,\n    }\n  } else {\n    // Remove any previously created descendant nodes as they're all due\n    // to be recreated.\n    if (oldNode) {\n      const descendantNodes = findChildrenRecursively(oldNode.children)\n      if (descendantNodes.length > 0) {\n        deleteAction = actions.deleteNodes(descendantNodes)\n      }\n    }\n\n    updateNodeAction = {\n      type: `CREATE_NODE`,\n      plugin,\n      traceId,\n      payload: node,\n    }\n  }\n\n  if (deleteAction) {\n    return [deleteAction, updateNodeAction]\n  } else {\n    return updateNodeAction\n  }\n}\n\n/**\n * \"Touch\" a node. Tells Gatsby a node still exists and shouldn't\n * be garbage collected. Primarily useful for source plugins fetching\n * nodes from a remote system that can return only nodes that have\n * updated. The source plugin then touches all the nodes that haven't\n * updated but still exist so Gatsby knows to keep them.\n * @param {string} nodeId The id of a node.\n * @example\n * touchNode(`a-node-id`)\n */\nactions.touchNode = (nodeId: string, plugin?: Plugin) => {\n  return {\n    type: `TOUCH_NODE`,\n    plugin,\n    payload: nodeId,\n  }\n}\n\ntype CreateNodeInput = {\n  node: Object,\n  fieldName?: string,\n  fieldValue?: string,\n  name?: string,\n  value: any,\n}\n/**\n * Extend another node. The new node field is placed under the `fields`\n * key on the extended node object.\n *\n * Once a plugin has claimed a field name the field name can't be used by\n * other plugins.  Also since nodes are immutable, you can't mutate the node\n * directly. So to extend another node, use this.\n * @param {Object} $0\n * @param {Object} $0.node the target node object\n * @param {string} $0.fieldName [deprecated] the name for the field\n * @param {string} $0.fieldValue [deprecated] the value for the field\n * @param {string} $0.name the name for the field\n * @param {string} $0.value the value for the field\n * @example\n * createNodeField({\n *   node,\n *   name: `happiness`,\n *   value: `is sweet graphql queries`\n * })\n *\n * // The field value is now accessible at node.fields.happiness\n */\nactions.createNodeField = (\n  { node, name, value, fieldName, fieldValue }: CreateNodeInput,\n  plugin: Plugin,\n  traceId?: string\n) => {\n  if (fieldName) {\n    console.warn(\n      `Calling \"createNodeField\" with \"fieldName\" is deprecated. Use \"name\" instead`\n    )\n    if (!name) {\n      name = fieldName\n    }\n  }\n  if (fieldValue) {\n    console.warn(\n      `Calling \"createNodeField\" with \"fieldValue\" is deprecated. Use \"value\" instead`\n    )\n    if (!value) {\n      value = fieldValue\n    }\n  }\n  // Ensure required fields are set.\n  if (!node.internal.fieldOwners) {\n    node.internal.fieldOwners = {}\n  }\n  if (!node.fields) {\n    node.fields = {}\n  }\n\n  /**\n   * Normalized name of the field that will be used in schema\n   */\n  const schemaFieldName = _.includes(name, `___NODE`)\n    ? name.split(`___`)[0]\n    : name\n\n  // Check that this field isn't owned by another plugin.\n  const fieldOwner = node.internal.fieldOwners[schemaFieldName]\n  if (fieldOwner && fieldOwner !== plugin.name) {\n    throw new Error(\n      stripIndent`\n      A plugin tried to update a node field that it doesn't own:\n\n      Node id: ${node.id}\n      Plugin: ${plugin.name}\n      name: ${name}\n      value: ${value}\n      `\n    )\n  }\n\n  // Update node\n  node.fields[name] = value\n  node.internal.fieldOwners[schemaFieldName] = plugin.name\n\n  return {\n    type: `ADD_FIELD_TO_NODE`,\n    plugin,\n    traceId,\n    payload: node,\n  }\n}\n\n/**\n * Creates a link between a parent and child node. This is used when you\n * transform content from a node creating a new child node. You need to add\n * this new child node to the `children` array of the parent but since you\n * don't have direct access to the immutable parent node, use this action\n * instead.\n * @param {Object} $0\n * @param {Object} $0.parent the parent node object\n * @param {Object} $0.child the child node object\n * @example\n * createParentChildLink({ parent: parentNode, child: childNode })\n */\nactions.createParentChildLink = (\n  { parent, child }: { parent: any, child: any },\n  plugin?: Plugin\n) => {\n  // Update parent\n  parent.children.push(child.id)\n  parent.children = _.uniq(parent.children)\n\n  return {\n    type: `ADD_CHILD_NODE_TO_PARENT_NODE`,\n    plugin,\n    payload: parent,\n  }\n}\n\n/**\n * Create a dependency between a page and data. Probably for\n * internal use only.\n * @param {Object} $0\n * @param {string} $0.path the path to the page\n * @param {string} $0.nodeId A node ID\n * @param {string} $0.connection A connection type\n * @private\n */\nactions.createPageDependency = (\n  {\n    path,\n    nodeId,\n    connection,\n  }: { path: string, nodeId: string, connection: string },\n  plugin: string = ``\n) => {\n  return {\n    type: `CREATE_COMPONENT_DEPENDENCY`,\n    plugin,\n    payload: {\n      path,\n      nodeId,\n      connection,\n    },\n  }\n}\n\n/**\n * Delete dependencies between an array of pages and data. Probably for\n * internal use only. Used when deleting pages.\n * @param {Array} paths the paths to delete.\n * @private\n */\nactions.deleteComponentsDependencies = (paths: string[]) => {\n  return {\n    type: `DELETE_COMPONENTS_DEPENDENCIES`,\n    payload: {\n      paths,\n    },\n  }\n}\n\n/**\n * When the query watcher extracts a graphq query, it calls\n * this to store the query with its component.\n * @private\n */\nactions.replaceComponentQuery = ({\n  query,\n  componentPath,\n}: {\n  query: string,\n  componentPath: string,\n}) => {\n  return {\n    type: `REPLACE_COMPONENT_QUERY`,\n    payload: {\n      query,\n      componentPath,\n    },\n  }\n}\n\n/**\n * Create a \"job\". This is a long-running process that are generally\n * started as side-effects to GraphQL queries.\n * [`gatsby-plugin-sharp`](/packages/gatsby-plugin-sharp/) uses this for\n * example.\n *\n * Gatsby doesn't finish its bootstrap until all jobs are ended.\n * @param {Object} job A job object with at least an id set\n * @param {id} job.id The id of the job\n * @example\n * createJob({ id: `write file id: 123`, fileName: `something.jpeg` })\n */\nactions.createJob = (job: Job, plugin?: ?Plugin = null) => {\n  return {\n    type: `CREATE_JOB`,\n    plugin,\n    payload: job,\n  }\n}\n\n/**\n * Set (update) a \"job\". Sometimes on really long running jobs you want\n * to update the job as it continues.\n *\n * @param {Object} job A job object with at least an id set\n * @param {id} job.id The id of the job\n * @example\n * setJob({ id: `write file id: 123`, progress: 50 })\n */\nactions.setJob = (job: Job, plugin?: ?Plugin = null) => {\n  return {\n    type: `SET_JOB`,\n    plugin,\n    payload: job,\n  }\n}\n\n/**\n * End a \"job\".\n *\n * Gatsby doesn't finish its bootstrap until all jobs are ended.\n * @param {Object} job  A job object with at least an id set\n * @param {id} job.id The id of the job\n * @example\n * endJob({ id: `write file id: 123` })\n */\nactions.endJob = (job: Job, plugin?: ?Plugin = null) => {\n  return {\n    type: `END_JOB`,\n    plugin,\n    payload: job,\n  }\n}\n\n/**\n * Set plugin status. A plugin can use this to save status keys e.g. the last\n * it fetched something. These values are persisted between runs of Gatsby.\n *\n * @param {Object} status  An object with arbitrary values set\n * @example\n * setPluginStatus({ lastFetched: Date.now() })\n */\nactions.setPluginStatus = (\n  status: { [key: string]: mixed },\n  plugin: Plugin\n) => {\n  return {\n    type: `SET_PLUGIN_STATUS`,\n    plugin,\n    payload: status,\n  }\n}\n\n/**\n * Create a redirect from one page to another. Server redirects don't work out\n * of the box. You must have a plugin setup to integrate the redirect data with\n * your hosting technology e.g. the [Netlify\n * plugin](/packages/gatsby-plugin-netlify/)).\n *\n * @param {Object} redirect Redirect data\n * @param {string} redirect.fromPath Any valid URL. Must start with a forward slash\n * @param {boolean} redirect.isPermanent This is a permanent redirect; defaults to temporary\n * @param {string} redirect.toPath URL of a created page (see `createPage`)\n * @param {boolean} redirect.redirectInBrowser Redirects are generally for redirecting legacy URLs to their new configuration. If you can't update your UI for some reason, set `redirectInBrowser` to true and Gatsby will handle redirecting in the client as well.\n * @example\n * createRedirect({ fromPath: '/old-url', toPath: '/new-url', isPermanent: true })\n * createRedirect({ fromPath: '/url', toPath: '/zn-CH/url', Language: 'zn' })\n */\nactions.createRedirect = ({\n  fromPath,\n  isPermanent = false,\n  redirectInBrowser = false,\n  toPath,\n  ...rest\n}) => {\n  let pathPrefix = ``\n  if (store.getState().program.prefixPaths) {\n    pathPrefix = store.getState().config.pathPrefix\n  }\n\n  return {\n    type: `CREATE_REDIRECT`,\n    payload: {\n      fromPath: `${pathPrefix}${fromPath}`,\n      isPermanent,\n      redirectInBrowser,\n      toPath: `${pathPrefix}${toPath}`,\n      ...rest,\n    },\n  }\n}\n\n/**\n * All defined actions.\n */\nexports.actions = actions\n\n/**\n * All action creators wrapped with a dispatch.\n */\nexports.boundActionCreators = bindActionCreators(actions, store.dispatch)\n"]}